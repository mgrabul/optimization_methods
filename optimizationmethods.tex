\documentclass[11pt]{article}

    \usepackage[breakable]{tcolorbox}
    \usepackage{parskip} % Stop auto-indenting (to mimic markdown behaviour)
    

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    \let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionFormat{nocaption}{}
    \captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro

    \usepackage{iftex}
    \ifPDFTeX
        \usepackage[T1]{fontenc}
        \IfFileExists{alphabeta.sty}{
              \usepackage{alphabeta}
          }{
              \usepackage[mathletters]{ucs}
              \usepackage[utf8x]{inputenc}
          }
    \else
        \usepackage{fontspec}
        \usepackage{unicode-math}
    \fi

    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics
                         % to support a larger range
    \makeatletter % fix for old versions of grffile with XeLaTeX
    \@ifpackagelater{grffile}{2019/11/01}
    {
      % Do nothing on new versions
    }
    {
      \def\Gread@@xetex#1{%
        \IfFileExists{"\Gin@base".bb}%
        {\Gread@eps{\Gin@base.bb}}%
        {\Gread@@xetex@aux#1}%
      }
    }
    \makeatother
    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{titling}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage{array}     % table support for pandoc >= 2.11.3
    \usepackage{calc}      % table minipage width calculation for pandoc >= 2.11.1
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{soul}      % strikethrough (\st) support for pandoc >= 3.0.0
    \usepackage{mathrsfs}
    

    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % common color for the border for error outputs.
    \definecolor{outerrorbackground}{HTML}{FFDFDF}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}

    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}


    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    % Document parameters
    % Document title
    \title{Python for Fundamental Optimization Methods}
    
    
    
    
    
    \author{Marko Grabuloski}
    
    
    
% Pygments definitions
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\@namedef{PY@tok@w}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\@namedef{PY@tok@c}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cp}{\def\PY@tc##1{\textcolor[rgb]{0.61,0.40,0.00}{##1}}}
\@namedef{PY@tok@k}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kt}{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\@namedef{PY@tok@o}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ow}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@nb}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nf}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@ne}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.80,0.25,0.22}{##1}}}
\@namedef{PY@tok@nv}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@no}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\@namedef{PY@tok@nl}{\def\PY@tc##1{\textcolor[rgb]{0.46,0.46,0.00}{##1}}}
\@namedef{PY@tok@ni}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.44,0.44,0.44}{##1}}}
\@namedef{PY@tok@na}{\def\PY@tc##1{\textcolor[rgb]{0.41,0.47,0.13}{##1}}}
\@namedef{PY@tok@nt}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nd}{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@s}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sd}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@si}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.64,0.35,0.47}{##1}}}
\@namedef{PY@tok@se}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.36,0.12}{##1}}}
\@namedef{PY@tok@sr}{\def\PY@tc##1{\textcolor[rgb]{0.64,0.35,0.47}{##1}}}
\@namedef{PY@tok@ss}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sx}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@m}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@gh}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@gu}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\@namedef{PY@tok@gd}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\@namedef{PY@tok@gi}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.52,0.00}{##1}}}
\@namedef{PY@tok@gr}{\def\PY@tc##1{\textcolor[rgb]{0.89,0.00,0.00}{##1}}}
\@namedef{PY@tok@ge}{\let\PY@it=\textit}
\@namedef{PY@tok@gs}{\let\PY@bf=\textbf}
\@namedef{PY@tok@gp}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@go}{\def\PY@tc##1{\textcolor[rgb]{0.44,0.44,0.44}{##1}}}
\@namedef{PY@tok@gt}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\@namedef{PY@tok@err}{\def\PY@bc##1{{\setlength{\fboxsep}{\string -\fboxrule}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}}
\@namedef{PY@tok@kc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kd}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kr}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@bp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@fm}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@vc}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vg}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vi}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vm}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sa}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sb}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sc}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@dl}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s2}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sh}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s1}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@mb}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mf}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mh}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mi}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@il}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mo}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ch}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cm}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cpf}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@c1}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cs}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % For linebreaks inside Verbatim environment from package fancyvrb.
    \makeatletter
        \newbox\Wrappedcontinuationbox
        \newbox\Wrappedvisiblespacebox
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}}
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}}
        \newcommand*\Wrappedcontinuationindent {3ex }
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox}
        % Take advantage of the already applied Pygments mark-up to insert
        % potential linebreaks for TeX processing.
        %        {, <, #, %, $, ' and ": go to next line.
        %        _, }, ^, &, >, - and ~: stay at end of broken line.
        % Use of \textquotesingle for straight quote.
        \newcommand*\Wrappedbreaksatspecials {%
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}%
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}%
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}%
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}%
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}%
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}%
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}%
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}%
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}%
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}%
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}%
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}%
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}%
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}%
        }
        % Some characters . , ; ? ! / are not pygmentized.
        % This macro makes them "active" and they will insert potential linebreaks
        \newcommand*\Wrappedbreaksatpunct {%
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}%
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}%
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}%
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}%
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}%
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}%
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}%
            \catcode`\.\active
            \catcode`\,\active
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active
            \lccode`\~`\~
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%

        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active
        \OriginalVerbatim[#1,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{F7F7F7}

    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        {\ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}}
    }
    

    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

\begin{document}
    
    \maketitle
    
    

    
    

    \tableofcontents

    \newpage

\section{Introduction}\label{introduction}

The seminar work contains three chapters. It begins with a basic
introduction to Python, followed by linear algebra concepts and their
implementation in Python. In the final chapter, foundational
optimization algorithms are introduced, where all previously explained
concepts and developed algorithms are put to use. This structured
progression allows readers to build essential Python skills for
mathematical applications, establishing a solid foundation for
understanding basic optimization algorithms. It also serves as a
valuable introduction to using Python for various mathematical tasks and
projects.

Specific attention is maintained on a structured approach where the code
is modular and reusable. The recursive nature of optimization methods is
illustrated through this modular design, and Python's functional
programming capabilities are leveraged by passing functions as arguments
to define iteration logic, convergence criteria, and method-specific
computations. This approach allows the mathematical relationships within
each algorithm to be clearly represented, emphasizing both reusability
and the structural similarities and differences across methods. The
methods are developed gradually, with more complex techniques relying on
functions initially crafted for simpler methods, reinforcing
understanding through progressive complexity.

The entire code is designed to be executed in Jupyter Notebook or Google
Colab, offering readers an interactive environment to experiment with
each optimization technique. This hands-on approach not only deepens
understanding but also makes Python a practical tool for mathematical
and optimization-based applications.

This seminar work is created for the subject Optimization Methods as
part of the master's program at the University of Information Science
and Technology St.~Paul the Apostle.

    \newpage

\section{Python Introduction}\label{python-introduction}

Python is a general-purpose high-level programming language. It was
invented in the late '80s, and its current major version is 3. Important
features and characteristics of Python include:

\begin{itemize}
\tightlist
\item
  Object-oriented
\item
  Dynamically typed
\item
  Open source
\item
  High-level
\item
  Interpreted
\item
  First-class functions
\item
  Higher-order functions
\end{itemize}

Python code is interpreted, meaning it is transformed into byte code one
line at a time during execution. There is no separate compile phase, so
no compile time is needed. Popular uses of Python include scripting and
automation, microservices, statistics, and machine learning.

Due to its open-source nature and well-developed libraries for
computation and visualization, such as NumPy and Matplotlib, Python has
become quite popular in math-related fields, especially in universities
and academia. It has increasingly replaced previously well-established
software like ``Wolfram Mathematica'' and ``MATLAB.''

    \newpage

\subsection{Basic Python commands}\label{basic-python-commands}

    Traditionally, every tutorial for a programming language starts with an
introduction on how to display output to the screen or use the print
command. Printing is done with the function \texttt{print}.

\textbf{Example}: Print ``Hello, World!''

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Print a string}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Hello World}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Hello World
    \end{Verbatim}

    While printing, strings and numbers can be concatenated using the ,
sign.

\textbf{Example}. Concatenate the words ``Hello'' and ``World'' and
print them.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{3}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Concatenating and printing strings}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Concatenating Hello and World with +: }\PY{l+s+s2}{\PYZdq{}}\PY{o}{+}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Hello}\PY{l+s+s2}{\PYZdq{}}\PY{o}{+}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ World}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Concatenating Hello and World with +: }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Hello}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ World}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Concatenating Hello and World with +: Hello World
Concatenating Hello and World with +:  Hello  World
    \end{Verbatim}

    \subsection{Declaring variables in
Python}\label{declaring-variables-in-python}

    Python is a dynamic language, and memory is assigned at execution time.
This means that variables don't need to be associated with a type at the
time of declaration; they receive their type at the time of
initialization. As a result, only initialization is required.
Additionally, because Python is dynamic, different types of data can be
assigned to the same variable, although this is generally not considered
good practice.

In Python, the symbol \texttt{:} can be used to provide hints on the
variable type. These hints are used by development environments to
provide information to the developer. Using type hints improves code
quality and makes the coding process easier.

\textbf{Example}. Assign 1 and 2 to integer variables \texttt{x},
\texttt{y} and print their values

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{x} \PY{o}{=} \PY{l+m+mi}{1}
\PY{c+c1}{\PYZsh{} int is a hint and not required in the following expression}
\PY{n}{y}\PY{p}{:}\PY{n+nb}{int} \PY{o}{=} \PY{l+m+mi}{2}

\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{x is:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{x}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{y is:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{y}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
x is:
1
y is:
2
    \end{Verbatim}

    Almost anything can be printed using concatenation, but Python offers a
more elegant way of formatting. Simple formatting is done by using the
letter \texttt{f} before the string. Instead of concatenating, variables
can be inserted directly into the string using \texttt{\{\}}.

\textbf{Example}: Using string formatting to print \texttt{x=1,\ y=2}
where \texttt{x} and \texttt{y} are integer variables.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{5}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{x} \PY{o}{=} \PY{l+m+mi}{1}
\PY{c+c1}{\PYZsh{} int is a hint and not required in the following expression}
\PY{n}{y}\PY{p}{:}\PY{n+nb}{int} \PY{o}{=} \PY{l+m+mi}{2}

\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{x=}\PY{l+s+si}{\PYZob{}}\PY{n}{x}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, y=}\PY{l+s+si}{\PYZob{}}\PY{n}{y}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
x=1, y=2
    \end{Verbatim}

    Similarly, a string can be formatted into two lines using
\texttt{"\textbackslash{}n"} as a line break.

\textbf{Example}. Print one string in two lines using the
\texttt{"\textbackslash{}n"} line brake.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{To print in a new line use }\PY{l+s+se}{\PYZbs{}\PYZbs{}}\PY{l+s+s2}{n }\PY{l+s+se}{\PYZbs{}\PYZbs{}}\PY{l+s+s2}{n The following text will be printed in a new line:}\PY{l+s+se}{\PYZbs{}\PYZbs{}}\PY{l+s+s2}{n}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{text in a new line}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
To print in a new line use \textbackslash{}n \textbackslash{}n The following text will be printed in a new
line:\textbackslash{}n'text in a new line'
    \end{Verbatim}

    \subsection{Basic data types in
Python}\label{basic-data-types-in-python}

\begin{itemize}
\tightlist
\item
  Text Type: str
\item
  Numeric Types: int, float, complex
\item
  Sequence Types: list, tuple, range
\item
  Mapping Type: dict
\item
  Set Types: set, frozenset
\item
  Boolean Type: bool
\item
  Binary Types: bytes, bytearray, memoryview
\item
  None Type: NoneType
\end{itemize}

\textbf{Example}. Declare the most common data types in Python.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Strings, datatypes that hold text.}
\PY{n}{x1}\PY{p}{:} \PY{n+nb}{str} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Hello World}\PY{l+s+s2}{\PYZdq{}}

\PY{c+c1}{\PYZsh{} Integers, positive and negative whole numbers.}
\PY{n}{x2}\PY{p}{:} \PY{n+nb}{int} \PY{o}{=} \PY{l+m+mi}{20}

\PY{c+c1}{\PYZsh{} Floats, datatypes that are generally used to represent real numbers.}
\PY{c+c1}{\PYZsh{} Mathematically speaking, they are real numbers with a precision of usually 16\PYZhy{}17 digits.}
\PY{n}{x3}\PY{p}{:} \PY{n+nb}{float} \PY{o}{=} \PY{l+m+mf}{20.5}

\PY{c+c1}{\PYZsh{} Complex numbers, used to represent numbers with a real and an imaginary part.}
\PY{c+c1}{\PYZsh{} They have precision similar to floats.}
\PY{n}{x4}\PY{p}{:} \PY{n+nb}{complex} \PY{o}{=} \PY{l+m+mi}{1}\PY{n}{j}

\PY{c+c1}{\PYZsh{} List or array, collections of indexed elements. The elements don\PYZsq{}t have to be unique.}
\PY{n}{x5}\PY{p}{:} \PY{n+nb}{list} \PY{o}{=} \PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{apple}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{banana}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cherry}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}
\PY{c+c1}{\PYZsh{} The indexing starts from 0. e.g., access the second element of a list}
\PY{n}{x5\PYZus{}2} \PY{o}{=} \PY{n}{x5}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}

\PY{c+c1}{\PYZsh{} Tuple, collections of indexed elements similar to lists but are immutable once}
\PY{c+c1}{\PYZsh{} created. This type of variable is not used in this book. It is used to}
\PY{c+c1}{\PYZsh{} represent static data that is stored in memory.}
\PY{n}{x6}\PY{p}{:} \PY{n+nb}{tuple} \PY{o}{=} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{apple}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{banana}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cherry}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Range, immutable sequences of numbers, usually used for looping or iterating}
\PY{c+c1}{\PYZsh{} in arrays or other data structures.}
\PY{n}{x7}\PY{p}{:} \PY{n+nb}{range} \PY{o}{=} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{6}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Dictionary, key\PYZhy{}value pair data structure where keys are unique. Usually used}
\PY{c+c1}{\PYZsh{} when building JSON objects or storing data. This variable is not used in this}
\PY{c+c1}{\PYZsh{} book.}
\PY{n}{x8}\PY{p}{:} \PY{n+nb}{dict} \PY{o}{=} \PY{p}{\PYZob{}}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{name}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{John}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{age}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{l+m+mi}{36}\PY{p}{\PYZcb{}}

\PY{c+c1}{\PYZsh{} Access an element in the dictionary}
\PY{n}{x8\PYZus{}name} \PY{o}{=} \PY{n}{x8}\PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{name}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}

\PY{c+c1}{\PYZsh{} Set, unordered collections of unique elements. Not used in this book. Usually}
\PY{c+c1}{\PYZsh{} used to store or keep track of unique values.}
\PY{n}{x9}\PY{p}{:} \PY{n+nb}{set} \PY{o}{=} \PY{p}{\PYZob{}}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{apple}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{banana}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cherry}\PY{l+s+s2}{\PYZdq{}}\PY{p}{\PYZcb{}}

\PY{c+c1}{\PYZsh{} Frozenset, unordered collections of unique elements. Unlike sets, they are}
\PY{c+c1}{\PYZsh{} immutable. Not used in this book. Could be used to store certain static}
\PY{c+c1}{\PYZsh{} parameters inside a client application or server from initialization until}
\PY{c+c1}{\PYZsh{} the end of the application.}
\PY{n}{x10}\PY{p}{:} \PY{n+nb}{frozenset} \PY{o}{=} \PY{n+nb}{frozenset}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{apple}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{banana}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cherry}\PY{l+s+s2}{\PYZdq{}}\PY{p}{\PYZcb{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Boolean, represents True or False values. Mostly used for conditional statements.}
\PY{n}{x11}\PY{p}{:} \PY{n+nb}{bool} \PY{o}{=} \PY{k+kc}{True}

\PY{c+c1}{\PYZsh{} Bytes, sequences of bytes. Once a bytes object is created, its elements cannot}
\PY{c+c1}{\PYZsh{} be changed. Used when dealing with communication with embedded devices like}
\PY{c+c1}{\PYZsh{} electronic cards. This variable is not of interest for the purposes/range of}
\PY{c+c1}{\PYZsh{} this book.}
\PY{n}{x12}\PY{p}{:} \PY{n+nb}{bytes} \PY{o}{=} \PY{l+s+sa}{b}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Hello}\PY{l+s+s2}{\PYZdq{}}

\PY{c+c1}{\PYZsh{} Bytearray, similar to bytes but mutable, meaning elements can be changed.}
\PY{c+c1}{\PYZsh{} This variable is not of interest for the purposes/range of this book.}
\PY{n}{x13}\PY{p}{:} \PY{n+nb}{bytearray} \PY{o}{=} \PY{n+nb}{bytearray}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{)}

\PY{c+c1}{\PYZsh{} None, used to represent the absence of a value.}
\PY{n}{x14}\PY{p}{:} \PY{k+kc}{None} \PY{o}{=} \PY{k+kc}{None}
\end{Verbatim}
\end{tcolorbox}

    \textbf{\emph{When writing high-quality code, it is essential to select
variable types that satisfy the minimal requirements for the use case.
This seminar work has an educational purpose and balances efficient code
practices with clarity. For this reason, not necessarily the most
effective but the most common and recognizable data types are used.}}

    \subsection{Basic arithmetic operations in
Python}\label{basic-arithmetic-operations-in-python}

Python provides several built-in operators for basic arithmetic
operations. These are the most common ones:

\begin{itemize}
\tightlist
\item
  Addition (+): Adds two numbers together.
\item
  Subtraction (-): Subtracts one number from another.
\item
  Multiplication (*): Multiplies two numbers.
\item
  Division (/): Divides one number by another (returns a float).
\item
  Integer Division (//): Divides one number by another and returns the
  integer part of the result.
\item
  Modulo (\%), returns the remainder when one number is divided by
  another.
\item
  Exponentiation (**): Raises one number to the power of another.
\end{itemize}

\textbf{Example}. Demonstrate the usage the most common built-in
operators in Python.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Addition}
\PY{n}{result} \PY{o}{=} \PY{l+m+mi}{5} \PY{o}{+} \PY{l+m+mi}{3}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Addition:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{result}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Subtraction}
\PY{n}{result} \PY{o}{=} \PY{l+m+mi}{5} \PY{o}{\PYZhy{}} \PY{l+m+mi}{3}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Subtraction:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{result}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Multiplication}
\PY{n}{result} \PY{o}{=} \PY{l+m+mi}{5} \PY{o}{*} \PY{l+m+mi}{3}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Multiplication:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{result}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Division}
\PY{n}{result} \PY{o}{=} \PY{l+m+mi}{5} \PY{o}{/} \PY{l+m+mi}{3}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Division:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{result}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Integer Division}
\PY{n}{result} \PY{o}{=} \PY{l+m+mi}{5} \PY{o}{/}\PY{o}{/} \PY{l+m+mi}{3}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Integer Division:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{result}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Modulo}
\PY{n}{result} \PY{o}{=} \PY{l+m+mi}{5} \PY{o}{\PYZpc{}} \PY{l+m+mi}{3}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Modulo:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{result}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Exponentiation}
\PY{n}{result} \PY{o}{=} \PY{l+m+mi}{2} \PY{o}{*}\PY{o}{*} \PY{l+m+mi}{3}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Exponentiation:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{result}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Addition: 8
Subtraction: 2
Multiplication: 15
Division: 1.6666666666666667
Integer Division: 1
Modulo: 2
Exponentiation: 8
    \end{Verbatim}

    \subsection{If - else conditions in
Python}\label{if---else-conditions-in-python}

The general form of an \texttt{if-else} condition in Python is:

\begin{verbatim}
if <bool>:
 <code block>
elif <bool>:
 <code block>
 .....
else:
 <code block>
\end{verbatim}

As shown, python uses the symbol \texttt{:} followed by new line with
indentation to indicate a start of a new block.

\textbf{Example}. Given a number \texttt{i}, print one of the following
``\texttt{i} is smaller or equal to 10'', ``\texttt{i} is smaller than
20'', ``\texttt{i} is equal to 20'', ``\texttt{i} is bigger than 20''
depending on \texttt{i}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{i\PYZus{}}\PY{p}{:}\PY{n+nb}{int} \PY{o}{=} \PY{l+m+mi}{12}

\PY{k}{if} \PY{n}{i\PYZus{}}\PY{o}{\PYZlt{}}\PY{o}{=}\PY{l+m+mi}{10}\PY{p}{:}
  \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{i is smaller or equal to 10}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{k}{elif} \PY{n}{i\PYZus{}}\PY{o}{\PYZlt{}}\PY{l+m+mi}{20}\PY{p}{:}
 \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{i is smaller than 20}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{k}{elif} \PY{n}{i\PYZus{}}\PY{o}{==}\PY{l+m+mi}{20}\PY{p}{:}
 \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{i is equal to 20}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{k}{else}\PY{p}{:}
 \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{i is bigger or equal than 20}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
i is smaller than 20
    \end{Verbatim}

    \newpage

\subsection{Loops and iterations in
Python}\label{loops-and-iterations-in-python}

As in other languages, commonly used loops in Python are \texttt{while}
and \texttt{for} loops. Additionally, Python supports functional
programming, and it is not uncommon for functions to be used instead of
declarative loops for interactions, especially when working with data
collections.

    The while loop syntax form in python is the following:

\begin{verbatim}
while <boolean>:
    <code block>
\end{verbatim}

\textbf{Example}. Using while loop print the elements of a list,
\texttt{l\ =\ \{1,2,3,"this\ is\ the\ last\ element\ of\ the\ list"\}}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{10}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{l} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{this is the last element of the list}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}

\PY{n}{index\PYZus{}l} \PY{o}{=} \PY{l+m+mi}{0}
\PY{k}{while}\PY{p}{(}\PY{n}{index\PYZus{}l}\PY{o}{\PYZlt{}}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{:}
  \PY{n+nb}{print}\PY{p}{(}\PY{n}{l}\PY{p}{[}\PY{n}{index\PYZus{}l}\PY{p}{]}\PY{p}{)}
  \PY{n}{index\PYZus{}l} \PY{o}{=} \PY{n}{index\PYZus{}l} \PY{o}{+} \PY{l+m+mi}{1}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1
2
3
this is the last element of the list
    \end{Verbatim}

    The general form of a \texttt{for} loop in Python is:

\begin{verbatim}
for variable in sequence:
    <code block>
\end{verbatim}

\textbf{Example}. Using for loop, print the elements of the list
\texttt{l\ =\ \{1,2,3,"this\ is\ the\ last\ element\ of\ the\ list"\}}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{11}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{l} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{this is the last element of the list}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}

\PY{k}{for} \PY{n}{element} \PY{o+ow}{in} \PY{n}{l}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{n}{element}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1
2
3
this is the last element of the list
    \end{Verbatim}

    Python supports functional programming, so it is becoming increasingly
popular to use functions instead of loops for iterating over data
structures. Built-in functions like \texttt{map} and \texttt{reduce} are
used to apply a function to the elements of a collection, such as a list
or set. This style of writing code is called declarative. In contrast,
imperative programming uses loops like \texttt{while} or \texttt{for} to
iterate over data structures. More detailed examples will be shown in
the functions section of this seminar work.

\newpage

\textbf{Example}. Using the map function print the elements of a list
\texttt{l\ =\ {[}1,2,3,"this\ is\ the\ last\ element\ of\ the\ list"{]}}
in Python

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{13}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{l} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{this is the last element of the list}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}

\PY{n+nb}{list}\PY{p}{(}\PY{n+nb}{map}\PY{p}{(}\PY{k}{lambda} \PY{n}{x}\PY{p}{:} \PY{n+nb}{print}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{,} \PY{n}{l}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1
2
3
this is the last element of the list
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{13}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
[None, None, None, None]
\end{Verbatim}
\end{tcolorbox}
        
    \newpage

\subsection{Functions in python}\label{functions-in-python}

Depending on how they are defined, there are generally two types of
functions in Python: lambda functions and standard functions. Standard
functions, or just functions, are traditional and quite flexible, but
they require more code to be defined. Lambda functions, on the other
hand, require less code but are not as flexible, as they are limited to
single-line expressions.

This seminar work will not use lambda functions, as they can be
completely replaced by standard functions. In general, lambda functions
are used with predefined functions like \texttt{map} or \texttt{reduce}
when iterating over data structures. They are often inlined with these
functions, which also contributes to code readability.

Standard function

\begin{verbatim}
def function_name(parameters):
   <Code block>
    <Command 1>
    <Command 2>
   ...
   </Code block>
   <!-- optional return -->
   return <value>
\end{verbatim}

Lambda function

\begin{verbatim}
lambda parameters: expression
\end{verbatim}

\textbf{Example}. Using a standard and a lambda function calculate the
sum of two numbers and print the output.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{sum\PYZus{}standard\PYZus{}function}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{y}\PY{p}{)}\PY{p}{:}
    \PY{n}{result} \PY{o}{=} \PY{n}{x} \PY{o}{+} \PY{n}{y}
    \PY{k}{return} \PY{n}{result}

\PY{c+c1}{\PYZsh{} Call the standard function and print the output}
\PY{n}{sum\PYZus{}standard} \PY{o}{=} \PY{n}{sum\PYZus{}standard\PYZus{}function}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Using Standard Function: }\PY{l+s+si}{\PYZob{}}\PY{n}{sum\PYZus{}standard}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{n}{sum\PYZus{}lambda\PYZus{}function} \PY{o}{=} \PY{k}{lambda} \PY{n}{x}\PY{p}{,} \PY{n}{y}\PY{p}{:} \PY{n}{x} \PY{o}{+} \PY{n}{y}

\PY{c+c1}{\PYZsh{} Call the lambda function and print the output}
\PY{n}{sum\PYZus{}lambda} \PY{o}{=} \PY{n}{sum\PYZus{}lambda\PYZus{}function}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Using Lambda Function: }\PY{l+s+si}{\PYZob{}}\PY{n}{sum\PYZus{}lambda}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Using Standard Function: 8
Using Lambda Function: 8
    \end{Verbatim}

    \textbf{Functions are ``first-class citizens'' in Python}, meaning they
are treated as variables. A function can be assigned to a variable,
passed to another function as a parameter, or returned from a function.
Treating functions as variables is part of the
\href{https://en.wikipedia.org/wiki/Functional_programming}{functional
programming paradigm}. These features are supported out of the box in
Python, and as a result, higher-order functions can be created quite
easily. In the following sections related to optimization, these Python
features and other elements of the functional programming paradigm will
be used extensively.

\textbf{Example}: Create a function that numerically calculates the
derivative of a function \(f(x)\) in \(x\),

\(f'(x) = \lim_{{\Delta x \to 0}} \frac{{f(x + \Delta x) - f(x)}}{\Delta x}\),

meaning instead of calculating the limit when \(\Delta x\) approaching
0, use an extremely small interval \((x-\Delta x, x + \Delta x)\) around
\(x\) to approximate the derivative, where \(\Delta x\) is very small (
e.g.~\(\Delta x =  10^{-5}\)).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{107}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{f}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{:}\PY{n+nb}{float}\PY{p}{)}\PY{p}{:}
  \PY{k}{return} \PY{n}{x\PYZus{}in}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}

\PY{k}{def} \PY{n+nf}{derivative\PYZus{}of}\PY{p}{(}\PY{n}{function\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{k}{def} \PY{n+nf}{numerical\PYZus{}derivative}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{)}\PY{p}{:}
    \PY{n}{\PYZus{}delta\PYZus{}x} \PY{o}{=} \PY{l+m+mf}{1e\PYZhy{}5}
    \PY{n}{\PYZus{}derivate\PYZus{}f} \PY{o}{=} \PY{p}{(}\PY{n}{function\PYZus{}in}\PY{p}{(}\PY{n}{x\PYZus{}in} \PY{o}{+} \PY{n}{\PYZus{}delta\PYZus{}x}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{n}{function\PYZus{}in}\PY{p}{(}\PY{n}{x\PYZus{}in} \PY{o}{\PYZhy{}} \PY{n}{\PYZus{}delta\PYZus{}x}\PY{p}{)}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{\PYZus{}delta\PYZus{}x}\PY{p}{)}
    \PY{k}{return} \PY{n}{\PYZus{}derivate\PYZus{}f}
  \PY{k}{return} \PY{n}{numerical\PYZus{}derivative}

\PY{n}{derivative\PYZus{}f} \PY{o}{=} \PY{n}{derivative\PYZus{}of}\PY{p}{(}\PY{n}{f}\PY{p}{)}

\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The approximation of the derivate of a function x\PYZca{}2 in x = 3 is }\PY{l+s+si}{\PYZob{}}\PY{n}{derivative\PYZus{}f}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
The approximation of the derivate of a function x\^{}2 in x = 3 is
6.000000000039306
    \end{Verbatim}

    \subsection{Libraries and modules}\label{libraries-and-modules}

Basic arithmetic operations with functions in Python include finding the
absolute value using \texttt{abs} and calculating the square root using
\texttt{math.sqrt}. The \texttt{abs} function is part of Python's
standard library, while \texttt{sqrt} is part of the math library, which
is commonly used but not included in the base library. Libraries are
collections of modules, and modules are collections of functions and
classes that are used for similar purposes. The math library needs to be
imported before it is used. To do so, write \texttt{import\ math} before
using it. Once imported, the functions and classes inside the library
can be used by accessing them with dot notation. For example,
\texttt{math.sqrt(9)} will return 3 as it calculates the square root of
nine.

Modules, on the other hand, are files containing Python code within a
library. For example, when using \texttt{import\ matplotlib.pyplot},
\texttt{pyplot} is a module in the \texttt{matplotlib} library that is
used for plotting data. Modules and libraries can be imported with
aliases instead of their full names. To define an alias for the module
\texttt{matplotlib.pyplot}, the following code line can be used:
\texttt{import\ matplotlib.pyplot\ as\ plt}.

\emph{As with every programming language, the necessary libraries need
to be imported and be part of the dependencies. The advantage of using
Google Colab is that it handles the dependencies itself, so only an
import statement for the required library is necessary.} \newpage

\textbf{Example}: Given a number, calculate the square root of the
absolute value of that number.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{108}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{math}

\PY{k}{def} \PY{n+nf}{calculate\PYZus{}sqrt\PYZus{}abs}\PY{p}{(}\PY{n}{num\PYZus{}in}\PY{p}{)}\PY{p}{:}
    \PY{n}{abs\PYZus{}num} \PY{o}{=} \PY{n+nb}{abs}\PY{p}{(}\PY{n}{num\PYZus{}in}\PY{p}{)}
    \PY{n}{sqrt\PYZus{}abs\PYZus{}num} \PY{o}{=} \PY{n}{math}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{abs\PYZus{}num}\PY{p}{)}
    \PY{k}{return} \PY{n}{sqrt\PYZus{}abs\PYZus{}num}

\PY{n}{number} \PY{o}{=} \PY{o}{\PYZhy{}}\PY{l+m+mi}{9}
\PY{n}{result} \PY{o}{=} \PY{n}{calculate\PYZus{}sqrt\PYZus{}abs}\PY{p}{(}\PY{n}{number}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The square root of the absolute value of }\PY{l+s+si}{\PYZob{}}\PY{n}{number}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ is }\PY{l+s+si}{\PYZob{}}\PY{n}{result}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
The square root of the absolute value of -9 is 3.0
    \end{Verbatim}

    \subsection{Logical Operators}\label{logical-operators}

Python uses \texttt{True} and \texttt{False} as boolean values.

The most popular logical operators are:

\begin{itemize}
\tightlist
\item
  \texttt{and}
\item
  \texttt{or}
\item
  \texttt{not}
\end{itemize}

Comparing values is done with:

\begin{itemize}
\tightlist
\item
  \texttt{\textless{}}, \texttt{\textless{}=}
\item
  \texttt{\textgreater{}}, \texttt{\textgreater{}=}
\item
  \texttt{==}
\end{itemize}

\textbf{Examples:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Given two numbers \texttt{a} and \texttt{b}, write a function that
  will return the larger number.
\item
  Given three numbers \texttt{a}, \texttt{b}, and \texttt{c}, write a
  function that will return the largest number.
\item
  Given two numbers \texttt{a} and \texttt{b}, write a function that
  returns \texttt{True} if \texttt{a\ \textgreater{}\ b}.
\item
  Write a function that, given a number \texttt{n}, prints the first
  \texttt{n} numbers.
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Example 1}
\PY{k}{def} \PY{n+nf}{max\PYZus{}of\PYZus{}two}\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{a} \PY{k}{if} \PY{n}{a} \PY{o}{\PYZgt{}} \PY{n}{b} \PY{k}{else} \PY{n}{b}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Max of 10 and 20:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{max\PYZus{}of\PYZus{}two}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{)}\PY{p}{)}  \PY{c+c1}{\PYZsh{} Output: 20}

\PY{c+c1}{\PYZsh{} Example 2}
\PY{k}{def} \PY{n+nf}{max\PYZus{}of\PYZus{}three}\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{,} \PY{n}{c}\PY{p}{)}\PY{p}{:}
    \PY{n}{pom} \PY{o}{=} \PY{n}{a}
    \PY{k}{if}\PY{p}{(}\PY{n}{b}\PY{o}{\PYZgt{}}\PY{n}{a}\PY{p}{)}\PY{p}{:}
      \PY{n}{pom} \PY{o}{=} \PY{n}{b}
    \PY{k}{if}\PY{p}{(}\PY{n}{c}\PY{o}{\PYZgt{}}\PY{n}{pom}\PY{p}{)}\PY{p}{:}
      \PY{n}{pom} \PY{o}{=} \PY{n}{c}
    \PY{k}{return} \PY{n}{pom}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Max of 50, 40, and 30:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{max\PYZus{}of\PYZus{}three}\PY{p}{(}\PY{l+m+mi}{50}\PY{p}{,} \PY{l+m+mi}{40}\PY{p}{,} \PY{l+m+mi}{30}\PY{p}{)}\PY{p}{)}  \PY{c+c1}{\PYZsh{} Output: 50}

\PY{c+c1}{\PYZsh{} Example 3}
\PY{k}{def} \PY{n+nf}{is\PYZus{}a\PYZus{}greater\PYZus{}than\PYZus{}b}\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{a} \PY{o}{\PYZgt{}} \PY{n}{b}
  
\PY{c+c1}{\PYZsh{} Example 4}
\PY{k}{def} \PY{n+nf}{print\PYZus{}first\PYZus{}n}\PY{p}{(}\PY{n}{n}\PY{p}{:}\PY{n+nb}{int}\PY{p}{)}\PY{p}{:}
  \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{First }\PY{l+s+si}{\PYZob{}}\PY{n}{n}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ positive integers:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
  \PY{n}{i}\PY{o}{=}\PY{l+m+mi}{1}
  \PY{k}{while}\PY{p}{(}\PY{o+ow}{not} \PY{n}{is\PYZus{}a\PYZus{}greater\PYZus{}than\PYZus{}b}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{n}\PY{p}{)}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{n}{i}\PY{p}{)}
    \PY{n}{i} \PY{o}{=} \PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}

\PY{n}{print\PYZus{}first\PYZus{}n}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Max of 10 and 20: 20
Max of 50, 40, and 30: 50
First 10 positive integers:
1
2
3
4
5
6
7
8
9
10
    \end{Verbatim}

    \subsection{Plotting Functions}\label{plotting-functions}

One of the reasons why Python is popular in mathematical-related areas
is because of the Matplotlib library. This library is used to draw or
plot on a coordinate system. It can be used for drawing functions, dots,
bars, histograms, and pie charts. It offers other useful options like
drawing in different colors, naming the axes of the coordinate system,
and naming the entire plot. It also supports drawing in both 2D and 3D.

\textbf{Examples:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Draw dots in a coordinate system.
\item
  Draw a function in a coordinate system over a given domain.
\item
  Draw a line in a coordinate system that passes through two dots.
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{110}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Optional, Customizing Matplotlib styles}
\PY{c+c1}{\PYZsh{} This step is not necessary and can be skipped, it makes sure that regardless of the system the plots will look the same.}
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}
\PY{n}{plt}\PY{o}{.}\PY{n}{rcParams}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{axes.prop\PYZus{}cycle}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{cycler}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{color}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{blue}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{green}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{red}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{cyan}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{magenta}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{yellow}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{black}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{rcParams}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{axes.facecolor}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{white}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{plt}\PY{o}{.}\PY{n}{rcParams}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{figure.facecolor}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{white}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{plt}\PY{o}{.}\PY{n}{rcParams}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{grid.color}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{lightgray}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{plt}\PY{o}{.}\PY{n}{rcParams}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{xtick.color}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{black}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{plt}\PY{o}{.}\PY{n}{rcParams}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ytick.color}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{black}\PY{l+s+s1}{\PYZsq{}}
\end{Verbatim}
\end{tcolorbox}

    \newpage

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{111}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{c+c1}{\PYZsh{} Example 1}
\PY{c+c1}{\PYZsh{} Draw dots}

\PY{c+c1}{\PYZsh{} Define coordinates for the dots}
\PY{n}{x\PYZus{}dots} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{]}
\PY{n}{y\PYZus{}dots} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{9}\PY{p}{,} \PY{l+m+mi}{16}\PY{p}{,} \PY{l+m+mi}{25}\PY{p}{]}

\PY{c+c1}{\PYZsh{} Plot the dots}
\PY{n}{plt}\PY{o}{.}\PY{n}{scatter}\PY{p}{(}\PY{n}{x\PYZus{}dots}\PY{p}{,} \PY{n}{y\PYZus{}dots}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{X}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{ylabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Y}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Dots in a Coordinate System}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{grid}\PY{p}{(}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 2}
\PY{c+c1}{\PYZsh{} Draw function}

\PY{c+c1}{\PYZsh{} Define the function}
\PY{k}{def} \PY{n+nf}{f}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{+} \PY{l+m+mi}{1}

\PY{c+c1}{\PYZsh{} Define the domain}
\PY{n}{x\PYZus{}func} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linspace}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{100}\PY{p}{)}  \PY{c+c1}{\PYZsh{} Adjust the domain as needed}

\PY{c+c1}{\PYZsh{} Plot the function}
\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{x\PYZus{}func}\PY{p}{,} \PY{n}{f}\PY{p}{(}\PY{n}{x\PYZus{}func}\PY{p}{)}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{X}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{ylabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Y}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Function in a Coordinate System}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{grid}\PY{p}{(}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 3}
\PY{c+c1}{\PYZsh{} Draw line}

\PY{c+c1}{\PYZsh{} Define the coordinates of the two dots}
\PY{n}{x\PYZus{}line} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{]}
\PY{n}{y\PYZus{}line} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{25}\PY{p}{]}

\PY{c+c1}{\PYZsh{} Plot the line passing through the two dots}
\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{x\PYZus{}line}\PY{p}{,} \PY{n}{y\PYZus{}line}\PY{p}{,} \PY{n}{marker}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{o}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{X}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{ylabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Y}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Line Passing Through Two Dots}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{grid}\PY{p}{(}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{optimizationmethods_files/optimizationmethods_41_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{optimizationmethods_files/optimizationmethods_41_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{optimizationmethods_files/optimizationmethods_41_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \newpage

\subsection{Basic Mathematical
Functions}\label{basic-mathematical-functions}

\textbf{Absolute Value}

The absolute value using NumPy can be calculated with
\texttt{np.abs(\textless{}np.array\textgreater{})} or \texttt{abs(x)}.
The \texttt{np.abs} function is used on a NumPy array and returns an
array where all elements are positive.

\textbf{Polynomial Functions}

A one-dimensional polynomial function is defined as:
\[f(x)=\sum_{k=0}^{n} a_k \cdot x^k\] Using the NumPy library, a
polynomial function can be created with \texttt{np.poly1d}, where the
\(a_k, 0 \leq k \leq n\) are elements of a \texttt{np.array}.

\textbf{Derivatives}

Accordingly, the derivative of a polynomial function is:
\[f'(x) = \sum_{k=1}^{n} k \cdot a_k \cdot x^{k-1}\] and the derivative
of a polynomial function \texttt{f} can be found using
\texttt{np.polyder(f)} where
\texttt{f=np.poly1d(\textless{}np.array\textgreater{})}.

Except for calculating derivatives of polynomial functions, NumPy does
not offer a function to calculate the derivative of any function.

This leaves us two popular options for calculating a derivative of a
general function:

\subsubsection{Custom function}\label{custom-function}

Write a function to calculate the derivative according to the definition
of a derivative. The function \texttt{derivative\_of} does exactly this
and can differentiate any one-dimensional Python function.

\textbf{Advantages:} The function \texttt{derivative\_of} returns a
function and as so supports higher-order derivatives. Additional
advantage of this method is that no additional library.

\textbf{Disadvantages:} The function \texttt{derivative\_of} supports
only one dimensional functions.

\emph{derivative\_of can be only used with used with mathematical
function, take a number as an input and return a number as an output}

\subsubsection{\texorpdfstring{\texttt{Sympy}-library}{Sympy-library}}\label{sympy-library}

The \texttt{sympy} library's \texttt{sympy.diff} function with
\texttt{sympy.symbols} is the most general and flexible solution for
symbolic differentiation. It allows the calculation of the derivative of
a function and can be used to calculate higher-order derivatives
(second, third, etc.). It can also be used to calculate partial
derivatives of a multi-dimensional function.

\textbf{Advantages:} It supports higher-order and partial derivatives.

\textbf{Disadvantages:} It can't operate on standard Python functions
but requires a special variable type (symbolic objects). Instead of
creating a standard Python function for the mathematical function whose
derivative is required, a symbolic object representing the mathematical
function is created. The operations of differentiation are then
performed on this object.

My suggestion is to use the \texttt{derivative\_of} function whenever
possible and to use \texttt{sympy.diff} for multi-dimensional functions.
Note that \texttt{sympy.diff} is not used in this seminar work.

\textbf{Integrals}

NumPy also does not offer functions for calculating bounded integrals or
integrals in general; they need to be calculated manually. The
\texttt{scipy.integrate} library can be used for approximation. Use
\texttt{scipy.integrate.nquad} for single-value functions and for
functions with more than one variable, and use
\texttt{scipy.integrate.trapz} for functions with more than one
dimension. Note that Integrals are not required or used in this seminar
work.

\emph{In general, multi-purpose programming languages do not offer
methods or libraries that can manipulate mathematical functions. They
usually offer a way to approximate them, perhaps because mathematical
functions are not a standard type of variable in general-purpose
languages.}

\textbf{Examples:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Calculate the first derivative of the polynomial function
  \(f(x) = 2*x^2 + 3*x -5\) and evaluate it in \(x = 3\).
\item
  Calculate the first and second derivatives of the polynomial function
  \(f(x) = 2*x^2 + 3*x -5\) and evaluate them in \(x = 3\) using the
  \texttt{derivative\_of} function.
\item
  Calculate the first and second derivatives of the function
  \(f(x) = 2*x^2 + 3*x -5\) and evaluate them in \(x = 3\) using the
  \texttt{sp.diff} function.
\item
  Calculate the partial derivatives of
  \(f(x) = 2 * x**2 + 3 * y**2 - 5\) with respect to \texttt{x} and
  \texttt{y} using the \texttt{sp.diff} function.
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{112}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Example 1}
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{k}{def} \PY{n+nf}{f}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{l+m+mi}{2} \PY{o}{*} \PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{+} \PY{l+m+mi}{3} \PY{o}{*} \PY{n}{x} \PY{o}{\PYZhy{}} \PY{l+m+mi}{5}
\PY{n}{x} \PY{o}{=} \PY{l+m+mi}{3}

\PY{c+c1}{\PYZsh{} Example 1}
\PY{c+c1}{\PYZsh{} the polynomial function is represented as a Python list}
\PY{n}{f\PYZus{}array} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{poly1d}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{5}\PY{p}{]}\PY{p}{)}
\PY{c+c1}{\PYZsh{} df is first derivative of f}
\PY{n}{df} \PY{o}{=} \PY{n}{f\PYZus{}array}\PY{o}{.}\PY{n}{deriv}\PY{p}{(}\PY{p}{)}
\PY{c+c1}{\PYZsh{} First derivative of f(x) is 4 * x + 3 \PYZhy{} 5}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The first derivative of f(x) = 2x\PYZca{}2 + 3x \PYZhy{} 5 in x = 3 is: }\PY{l+s+si}{\PYZob{}}\PY{n}{df}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 2}
\PY{c+c1}{\PYZsh{} df is first derivative of f}
\PY{n}{df} \PY{o}{=} \PY{n}{derivative\PYZus{}of}\PY{p}{(}\PY{n}{f}\PY{p}{)}
\PY{c+c1}{\PYZsh{} ddf is the second derivative of f}
\PY{n}{ddf} \PY{o}{=} \PY{n}{derivative\PYZus{}of}\PY{p}{(}\PY{n}{df}\PY{p}{)}
\PY{c+c1}{\PYZsh{} First derivative of f(x) is 4 * x + 3 \PYZhy{} 5}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The first derivative of f(x) = 2x\PYZca{}2 + 3x \PYZhy{} 5 in x = 3 is: }\PY{l+s+si}{\PYZob{}}\PY{n}{df}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{c+c1}{\PYZsh{} Second derivative of f(x) is 4}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The second derivative of f(x) = 2x\PYZca{}2 + 3x \PYZhy{} 5 in x = 3 is: }\PY{l+s+si}{\PYZob{}}\PY{n}{ddf}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 3}
\PY{k+kn}{import} \PY{n+nn}{sympy} \PY{k}{as} \PY{n+nn}{sp}
\PY{n}{x} \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{symbols}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{f} \PY{o}{=} \PY{l+m+mi}{2} \PY{o}{*} \PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{+} \PY{l+m+mi}{3} \PY{o}{*} \PY{n}{x} \PY{o}{\PYZhy{}} \PY{l+m+mi}{5}
\PY{c+c1}{\PYZsh{} df is first derivative of f}
\PY{n}{df} \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{n}{x}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The first derivative of }\PY{l+s+si}{\PYZob{}}\PY{n}{f}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ is }\PY{l+s+si}{\PYZob{}}\PY{n}{df}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The first derivative of }\PY{l+s+si}{\PYZob{}}\PY{n}{f}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ in x = 3 is}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{df}\PY{o}{.}\PY{n}{evalf}\PY{p}{(}\PY{n}{subs}\PY{o}{=}\PY{p}{\PYZob{}}\PY{n}{x}\PY{p}{:} \PY{l+m+mi}{3}\PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{)}
\PY{c+c1}{\PYZsh{} ddf is the second derivative of f}
\PY{n}{ddf} \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{df}\PY{p}{,} \PY{n}{x}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The second derivative of }\PY{l+s+si}{\PYZob{}}\PY{n}{f}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ is }\PY{l+s+si}{\PYZob{}}\PY{n}{ddf}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The first derivative of }\PY{l+s+si}{\PYZob{}}\PY{n}{f}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ in x = 3 is }\PY{l+s+si}{\PYZob{}}\PY{n}{ddf}\PY{o}{.}\PY{n}{evalf}\PY{p}{(}\PY{n}{subs}\PY{o}{=}\PY{p}{\PYZob{}}\PY{n}{x}\PY{p}{:}\PY{+w}{ }\PY{l+m+mi}{3}\PY{p}{\PYZcb{}}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 4}
\PY{k+kn}{import} \PY{n+nn}{sympy} \PY{k}{as} \PY{n+nn}{sp}
\PY{n}{x} \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{symbols}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{y} \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{symbols}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{y}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{f} \PY{o}{=} \PY{l+m+mi}{2} \PY{o}{*} \PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{+} \PY{l+m+mi}{3} \PY{o}{*} \PY{n}{y}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{\PYZhy{}} \PY{l+m+mi}{5}
\PY{c+c1}{\PYZsh{} df is first derivative of f}
\PY{n}{dxf} \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{n}{x}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The partial derivative of }\PY{l+s+si}{\PYZob{}}\PY{n}{f}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ with respect }\PY{l+s+si}{\PYZob{}}\PY{n}{x}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ is }\PY{l+s+si}{\PYZob{}}\PY{n}{dxf}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{c+c1}{\PYZsh{} ddf is the second derivative of f}
\PY{n}{dyf} \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{n}{y}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The partial derivative of }\PY{l+s+si}{\PYZob{}}\PY{n}{f}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ with respect }\PY{l+s+si}{\PYZob{}}\PY{n}{y}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ is }\PY{l+s+si}{\PYZob{}}\PY{n}{dyf}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
The first derivative of f(x) = 2x\^{}2 + 3x - 5 in x = 3 is: 15
The first derivative of f(x) = 2x\^{}2 + 3x - 5 in x = 3 is: 15.000000000142675
The second derivative of f(x) = 2x\^{}2 + 3x - 5 in x = 3 is: 4.000000330961484
The first derivative of 2*x**2 + 3*x - 5 is 4*x + 3
The first derivative of 2*x**2 + 3*x - 5 in x = 3 is 15.0000000000000
The second derivative of 2*x**2 + 3*x - 5 is 4
The first derivative of 2*x**2 + 3*x - 5 in x = 3 is 4.00000000000000
The partial derivative of 2*x**2 + 3*y**2 - 5 with respect x is 4*x
The partial derivative of 2*x**2 + 3*y**2 - 5 with respect y is 6*y
    \end{Verbatim}

    \newpage

\section{Arrays, Matrices, and Elements of Linear Algebra in
Python}\label{arrays-matrices-and-elements-of-linear-algebra-in-python}

Python has a rich set of functions and libraries for operations with
vectors and matrices. This is generally done using the libraries NumPy
and SymPy. Matrices offer a powerful way to handle linear algebra
operations. This text in the chapter on optimization algorithms will
extensively use linear algebra and the NumPy library.

    \subsection{Standard operations with lists in
Python}\label{standard-operations-with-lists-in-python}

Although not connected directly to linear algebra, standard lists in
python will be used in developing the optimization algorithms in the
next chapter of this text.

Most popular operations with the standard python list are:

\begin{itemize}
\tightlist
\item
  \textbf{Indexing}: \texttt{list{[}i{]}}, where \texttt{i} is the
  index.
\item
  \textbf{Appending}: \texttt{list.append(x)}, where \texttt{x} is
  appended at the end of the list.
\item
  \textbf{Removing}: \texttt{list.pop(i)}, where \texttt{i} is the index
  of the element to be deleted.
\item
  \textbf{Inserting}: \texttt{list.insert(i,\ x)}, where \texttt{x} is
  the element to be inserted and \texttt{i} is it's position index.
\item
  \textbf{Slicing}: \texttt{list{[}x:y{]}}, where \texttt{x} and
  \texttt{y} are the indices of the first and last elements of the
  returned list (inclusive of \texttt{x} and exclusive of \texttt{y}).
  \texttt{x} or \texttt{y} might be omitted, which would be interpreted
  as the start and end of the list, respectively.
\item
  \textbf{Length of a list}: \texttt{len(list)} - getting the size of
  the list.
\end{itemize}

\emph{When it comes to indexing, the first element of the list has index
0 and the last element can be accessed with -1.}

\textbf{Examples:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Define \texttt{list\_a} with 10 elements and print its first, second,
  and last elements.
\item
  Print the size of \texttt{list\_a}.
\item
  Append an element to the already defined \texttt{list\_a} and print
  the list.
\item
  Remove the second element of \texttt{list\_a} and print the list.
\item
  Insert an element in \texttt{list\_a} between the second and third
  elements and print the list.
\item
  From \texttt{list\_a}, use the slicing operator to create a new list,
  \texttt{list\_b}, that contains the elements from \texttt{list\_a}
  starting from index 3 and ending at index 5, including the elements at
  index 3 and 5.
\item
  From \texttt{list\_a}, use the slicing operator to create a list,
  \texttt{list\_b}, that does not contain the first 3 elements of
  \texttt{list\_a}.
\item
  From \texttt{list\_a}, use the slicing operator to create a list,
  \texttt{list\_b}, that does not contain the first 4 elements of
  \texttt{list\_a}, in the same order as in \texttt{list\_a}. \newpage
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{113}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Example 1}
\PY{c+c1}{\PYZsh{} Define list\PYZus{}a with 10 elements}
\PY{n}{list\PYZus{}a} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{,} \PY{l+m+mi}{7}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{,} \PY{l+m+mi}{9}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{]}
\PY{c+c1}{\PYZsh{} Print the first, second, and last elements}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{First element:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{list\PYZus{}a}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Second element:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{list\PYZus{}a}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Last element:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{list\PYZus{}a}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 2}
\PY{c+c1}{\PYZsh{} Print the list\PYZus{}a size}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Size of list\PYZus{}a:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n+nb}{len}\PY{p}{(}\PY{n}{list\PYZus{}a}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 3}
\PY{c+c1}{\PYZsh{} Append an element to list\PYZus{}a and print the list}
\PY{n}{list\PYZus{}a}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{l+m+mi}{11}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{List after appending an element:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{list\PYZus{}a}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 4}
\PY{c+c1}{\PYZsh{} Remove the second element of list\PYZus{}a and print the list}
\PY{n}{list\PYZus{}a}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{List after removing the second element:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{list\PYZus{}a}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 5}
\PY{c+c1}{\PYZsh{} Insert an element in list\PYZus{}a between the second and third elements and print the list}
\PY{n}{list\PYZus{}a}\PY{o}{.}\PY{n}{insert}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{15}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{List after inserting an element:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{list\PYZus{}a}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 6}
\PY{c+c1}{\PYZsh{} Create a new list list\PYZus{}b from list\PYZus{}a using the slicing operator from index 3 to 5}
\PY{n}{list\PYZus{}b} \PY{o}{=} \PY{n}{list\PYZus{}a}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{:}\PY{l+m+mi}{6}\PY{p}{]}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{List\PYZus{}b from index 3 to 5 of list\PYZus{}a:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{list\PYZus{}b}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 7}
\PY{c+c1}{\PYZsh{} Create a new list list\PYZus{}b from list\PYZus{}a excluding the first 3 elements}
\PY{n}{list\PYZus{}b} \PY{o}{=} \PY{n}{list\PYZus{}a}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{:}\PY{p}{]}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{List\PYZus{}b excluding the first 3 elements of list\PYZus{}a:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{list\PYZus{}b}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 8}
\PY{c+c1}{\PYZsh{} Create a new list list\PYZus{}b from list\PYZus{}a excluding the first 4 elements}
\PY{n}{list\PYZus{}b} \PY{o}{=} \PY{n}{list\PYZus{}a}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{:}\PY{p}{]}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{List\PYZus{}b excluding the first 4 elements of list\PYZus{}a:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{list\PYZus{}b}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
First element: 1
Second element: 2
Last element: 10
Size of list\_a: 10
List after appending an element: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
List after removing the second element: [1, 3, 4, 5, 6, 7, 8, 9, 10, 11]
List after inserting an element: [1, 3, 15, 4, 5, 6, 7, 8, 9, 10, 11]
List\_b from index 3 to 5 of list\_a: [4, 5, 6]
List\_b excluding the first 3 elements of list\_a: [4, 5, 6, 7, 8, 9, 10, 11]
List\_b excluding the first 4 elements of list\_a: [5, 6, 7, 8, 9, 10, 11]
    \end{Verbatim}

    \subsection{Numpy library, standard
operations}\label{numpy-library-standard-operations}

Creating a vector in Python can be done with the \texttt{numpy} library.
Vectors created using the \texttt{numpy} library are usually referred to
as \texttt{numpy} arrays or np arrays, and they are created from a list.
Before using the \texttt{numpy} library, it needs to be imported. The
standard way to import it is \texttt{import\ numpy\ as\ np}. This line
imports numpy as np, and from now on in this text, numpy will be
referenced and called np, as this is standard slang in Python.

\begin{verbatim}
import numpy as np
my_list = [1,2,3,4,5]
my_vector = np.array(my_list)
\end{verbatim}

The numpy library does not have any special data structure for a matrix,
but matrixes are created as an array of arrays

\begin{verbatim}
my_matrix = np.array([[1, 2, 3],[4, 5, 6],[7, 8, 9]])
\end{verbatim}

It is important to note that all the previously described functions and
operators that are applicable to the standard Python list are also
applicable to np arrays. Other useful functions that are part of the np
library but not directly connected to linear algebra are:

\begin{itemize}
\tightlist
\item
  \texttt{np.full}: Returns an array with a specified size and shape,
  prefilled with a provided element.
\item
  \texttt{np.linspace}: Generates evenly spaced numbers over a specified
  interval, useful for plotting functions.
\item
  \texttt{np.concatenate}: Joins together vectors and matrices, useful
  for solving linear systems or formalizing linear programs.
\item
  \texttt{np.vstack}: Stacks arrays in sequence vertically (row-wise),
  useful for concatenating matrices.
\item
  \texttt{np.hstack}: Stacks arrays in sequence horizontally
  (column-wise), useful for concatenating matrices.
\item
  \texttt{.shape}: Returns the number of rows and columns of a matrix.
\end{itemize}

\emph{In the context of NumPy, a matrix \texttt{A} with \texttt{m} rows
and \texttt{n}columns is said to have \textbf{shape}
\texttt{{[}m,\ n{]}}.}

\textbf{Examples:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an array with size 10, filled with the number 5.
\item
  Add additional 5 zeros to the end of the array.
\item
  Generate 10 values for the function \(f(x)=x^2\) on a domain between
  \texttt{{[}1,10{]}}.
\item
  Create a matrix \texttt{A1} with shape \texttt{{[}2,\ 3{]}}.
\item
  Create a matrix \texttt{A2} with shape \texttt{{[}2,\ 2{]}} and
  concatenate it with matrix \texttt{A1} so that the new matrix
  \texttt{A3\ =\ {[}A1\ A2{]}} is created with a shape
  \texttt{{[}2,\ 5{]}}.
\item
  Create a new matrix \texttt{A4} with a shape \texttt{{[}3,\ 5{]}} and
  concatenate it with the matrix \texttt{A3} so that
  \texttt{A5\ =\ {[}A3;\ A4{]}} is created with a shape
  \texttt{{[}5,\ 5{]}}.
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{114}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{c+c1}{\PYZsh{} Example 1}
\PY{c+c1}{\PYZsh{} Create an array with size 10, filled with the number 5}
\PY{n}{array} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{full}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Array filled with 5s:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{array}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 2}
\PY{c+c1}{\PYZsh{} Add additional 5 zeros to the end of the array}
\PY{n}{array} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{array}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Array with 5 zeros at the end:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{array}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 3}
\PY{c+c1}{\PYZsh{} Generate 10 values for the function f(x) = x\PYZca{}2 on the domain [1, 10]}
\PY{n}{x} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linspace}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{)}
\PY{n}{f\PYZus{}x} \PY{o}{=} \PY{n}{x} \PY{o}{*}\PY{o}{*} \PY{l+m+mi}{2}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Values of f(x)=x\PYZca{}2:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{f\PYZus{}x}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 3}
\PY{c+c1}{\PYZsh{} Create a matrix A1 with shape [2,3]}
\PY{n}{A1} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{full}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Matrix A1 with shape [2,3]:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{A1}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 4}
\PY{c+c1}{\PYZsh{} Create a matrix A2 with shape [2,2]}
\PY{n}{A2} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{full}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Matrix A2 with shape [2,2]:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{A2}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 5}
\PY{c+c1}{\PYZsh{} Concatenate A2 with A1 to create A3 with shape [2,5]}
\PY{n}{A3} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{hstack}\PY{p}{(}\PY{p}{(}\PY{n}{A1}\PY{p}{,} \PY{n}{A2}\PY{p}{)}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Matrix A3 with shape [2,5]:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{A3}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 6}
\PY{c+c1}{\PYZsh{} Create a matrix A4 with shape [3,5]}
\PY{n}{A4} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{full}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Matrix A4 with shape [3,5]:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{A4}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 7}
\PY{c+c1}{\PYZsh{} Concatenate A3 with A4 to create A5 with shape [5,5]}
\PY{n}{A5} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{vstack}\PY{p}{(}\PY{p}{(}\PY{n}{A3}\PY{p}{,} \PY{n}{A4}\PY{p}{)}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Matrix A5 with shape [5,5]:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{A5}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Array filled with 5s: [5 5 5 5 5 5 5 5 5 5]
Array with 5 zeros at the end: [5. 5. 5. 5. 5. 5. 5. 5. 5. 5. 0. 0. 0. 0. 0.]
Values of f(x)=x\^{}2: [  1.   4.   9.  16.  25.  36.  49.  64.  81. 100.]
Matrix A1 with shape [2,3]:
 [[1 1 1]
 [1 1 1]]
Matrix A2 with shape [2,2]:
 [[2 2]
 [2 2]]
Matrix A3 with shape [2,5]:
 [[1 1 1 2 2]
 [1 1 1 2 2]]
Matrix A4 with shape [3,5]:
 [[4 4 4 4 4]
 [4 4 4 4 4]
 [4 4 4 4 4]]
Matrix A5 with shape [5,5]:
 [[1 1 1 2 2]
 [1 1 1 2 2]
 [4 4 4 4 4]
 [4 4 4 4 4]
 [4 4 4 4 4]]
    \end{Verbatim}

    \subsection{\texorpdfstring{Linear algebra with
\texttt{Numpy}}{Linear algebra with Numpy}}\label{linear-algebra-with-numpy}

    \textbf{The following text will use vectors and matrices with elements
in the set of real numbers \(\mathbf{R}\).}

Vector addition with \texttt{np} is quite intuitive as it uses the
\texttt{+} operator. In mathematics, vector addition is defined between
two vectors with the same dimension. If the two vectors have different
dimensions, a \texttt{ValueError} exception is thrown.

\textbf{Example}: Sum two vectors \texttt{v1\ =\ {[}1,\ 2,\ 3{]}} and
\texttt{v2\ =\ {[}3,\ 4,\ 5{]}}, then print \texttt{v1}, \texttt{v2},
and \texttt{v1\ +\ v2}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{115}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{n}{v1} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
\PY{n}{v2} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{]}\PY{p}{)}

\PY{n}{v3} \PY{o}{=} \PY{n}{v1} \PY{o}{+} \PY{n}{v2}

\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Result of addition of }\PY{l+s+si}{\PYZob{}}\PY{n}{v1}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ and }\PY{l+s+si}{\PYZob{}}\PY{n}{v2}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ is }\PY{l+s+si}{\PYZob{}}\PY{n}{v3}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Result of addition of [1 2 3] and [3 4 5] is [4 6 8]
    \end{Verbatim}

    Matrix addition with \texttt{np} is also possible and follows the same
rules as vector addition, as matrices and vectors are represented with
\texttt{np.arrays}.

\textbf{Example}. Sum two matrices
\[ A = \begin{pmatrix} 1 & 2\\ 3 & 4 \end{pmatrix} \] and
\[ B= \begin{pmatrix} 5 & 6\\ 7 & 8 \end{pmatrix} \]

    

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{116}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{n}{A} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\PY{n}{B} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{7}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\PY{n}{C} \PY{o}{=} \PY{n}{A} \PY{o}{+} \PY{n}{B}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Sum of A and B:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{C}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Sum of A and B:
[[ 6  8]
 [10 12]]
    \end{Verbatim}

    \subsubsection{Transposed vectors and
matrices}\label{transposed-vectors-and-matrices}

In mathematics, a transposed vector \(\mathbf{a}^T\) of a vector \[
\mathbf{a} = \begin{bmatrix}
a_1 \\
a_2 \\
\vdots \\
a_n
\end{bmatrix}
\] is \[
\mathbf{a}^T = \begin{bmatrix}
a_1 & a_2 & \dots & a_n
\end{bmatrix}
\]

Similarly, for a matrix, a transposed matrix \(\mathbf{A}^T\) of a
matrix \[
\mathbf{A} = \begin{bmatrix}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
a_{m1} & a_{m2} & \cdots & a_{mn}
\end{bmatrix}
\] is \[
\mathbf{A}^T = \begin{bmatrix}
a_{11} & a_{21} & \cdots & a_{m1} \\
a_{12} & a_{22} & \cdots & a_{m2} \\
\vdots & \vdots & \ddots & \vdots \\
a_{1n} & a_{2n} & \cdots & a_{mn}
\end{bmatrix}
\]

Transposing a matrix in NumPy can be done using \texttt{A.T}, where
\texttt{A} is the matrix. Since in NumPy a vector is a special case of a
matrix or an array, the same method applies to vectors.

\emph{The interpretation of transposing a matrix is creating a new
matrix where the rows from the original matrix become columns and the
columns become rows.}

\newpage

\textbf{Examples:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  For a given vector, print the transposed vector.
\item
  For a given matrix, print the transposed matrix.
\item
  For a given matrix, print the transposed matrix.
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{c+c1}{\PYZsh{} Example 1}
\PY{c+c1}{\PYZsh{} Creating a 2D array (matrix)}
\PY{n}{a} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}

\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The transposed vector for the vector:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{a}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{is:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{a}\PY{o}{.}\PY{n}{T}\PY{p}{)}


\PY{c+c1}{\PYZsh{} Example 2}
\PY{c+c1}{\PYZsh{} Creating a 2D array (matrix)}
\PY{n}{A} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,}
              \PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{]}\PY{p}{,}
              \PY{p}{[}\PY{l+m+mi}{7}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{,} \PY{l+m+mi}{9}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The transposed matrix for the matrix:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{A}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{is:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{A}\PY{o}{.}\PY{n}{T}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
The transposed vector for the vector:
[1 2 3]
is:
[1 2 3]
The transposed matrix for the matrix:
[[1 2 3]
 [4 5 6]
 [7 8 9]]
is:
[[1 4 7]
 [2 5 8]
 [3 6 9]]
    \end{Verbatim}

    \newpage

\subsubsection{Dot Product of Vectors and Product of
Matrices}\label{dot-product-of-vectors-and-product-of-matrices}

The dot product for vectors \(\pmb{a}^T\) and \(\pmb{b}\) in
\(\pmb{R}^n\) where: \[
\pmb{a}^T = \begin{bmatrix}
a_1 \
a_2 \
\dots\
a_n
\end{bmatrix}, \quad
\pmb{b} = \begin{bmatrix}
b_1 \\
b_2 \\
\vdots \\
b_n
\end{bmatrix}
\]\\
is defined as: \[
\pmb{a}^T \pmb{b} = \sum_{i=1}^{n} a_i b_i
\]

The expression \(\sqrt{\pmb{x}^{T}\cdot\pmb{x}}\) is called the
Euclidean norm of the vector \(\pmb{x}\) and is denoted as
\(\|\pmb{x}\|\).

\emph{The interpretation of this norm is the size or length of the
vector.}

The vector product is also equal to:

\[\pmb{x} \cdot \pmb{y} = \|\pmb{x}\| \|\pmb{y}\| \cos(\theta)\]

where \(\theta\) is the angle between \(x\) and \(y\)

The cosine of the angle between two vectors can be calculated with: pmb
\[\cos(\theta) = \frac{\pmb{x} \cdot \pmb{y}}{\|\pmb{x}\| \|\pmb{y}\|}\]

\emph{The dot product is usually used for finding a projection \(a_b\)
of the vector \(a\) on the vector \(b\), \[
{\pmb{a_b}} = \left( \frac{\pmb{a}^T \cdot \pmb{b}}{\|\pmb{b}\|^2} \right) \pmb{b}
\]}.

Similarly, for matrices, product of two matrices \(A\) and \(B\) with
shapes \texttt{{[}n,k{]}} and \texttt{{[}k,m{]}} accordingly is an
\({AB}\) matrix with a shape \texttt{{[}n,m{]}} where the element
\({AB[i,j]}\) is a dot product of the i'th row vector and the j'th
column vector of \({B}\).

\[
AB[i,j] = \sum_{q=1}^{k} A[i,q] B[q,j]
\]

In \texttt{Nympy} the dot product can be found with
\texttt{np.dot(a,\ b)} and contrary to the mathematical definition it
does not require that one of the vectors be transposed.

\textbf{Examples:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Using the properties of the dot product and given two vectors
  \texttt{a={[}2,3{]}} and \texttt{b={[}4,5{]}} find a vector
  \texttt{a\_b} that will be the projection of a on b and plot it.
\item
  Given the linear function
  \texttt{f(x\_1..x\_4)=3x\_1+5x\_2-4x\_3+19x\_4\ +\ 3} in
  \texttt{x\ =\ {[}3,4,5,1{]}}, using the dot product x*a where a are
  the parameters of the linear function \texttt{a\ =\ {[}3,5,-4,19,3{]}}
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{118}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}

\PY{c+c1}{\PYZsh{} Example 1:}
\PY{n}{v1} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{]}\PY{p}{)}
\PY{n}{v2} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{5}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
\PY{n}{v1\PYZus{}v2} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{dot}\PY{p}{(}\PY{n}{v1}\PY{p}{,} \PY{n}{v2}\PY{p}{)}
\PY{n}{v2\PYZus{}v2} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{dot}\PY{p}{(}\PY{n}{v2}\PY{p}{,} \PY{n}{v2}\PY{p}{)}
\PY{n}{v1\PYZus{}proj\PYZus{}v2}\PY{o}{=}\PY{p}{(}\PY{n}{v1\PYZus{}v2}\PY{o}{/}\PY{p}{(}\PY{n}{v2\PYZus{}v2}\PY{p}{)}\PY{p}{)}\PY{o}{*}\PY{n}{v2}
\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{v1}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{v1}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{k:}\PY{l+s+s1}{\PYZsq{}} \PY{p}{,}\PY{n}{color}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{label}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{v1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{marker}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{o}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{v2}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{v2}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{k:}\PY{l+s+s1}{\PYZsq{}} \PY{p}{,}\PY{n}{color}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{g}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{label}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{v1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{marker}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{o}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{v1\PYZus{}proj\PYZus{}v2}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{v1\PYZus{}proj\PYZus{}v2}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{k:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{color}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{r}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{label}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{v1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{marker}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{o}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{grid}\PY{p}{(}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 2:}
\PY{n}{x} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
\PY{n}{x} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}
\PY{n}{a} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{19}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
\PY{n}{fx} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{dot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{a}\PY{p}{)}

\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{the value of f(x\PYZus{}1..x\PYZus{}4)=3x1+5x2\PYZhy{}4x3+19x4+3 in x=(3,4,5,1) is }\PY{l+s+si}{\PYZob{}}\PY{n}{fx}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
/var/folders/4s/hhswlq455zv2br9bkfsygsfr0000gn/T/ipykernel\_74508/1885378213.py:1
0: UserWarning: color is redundantly defined by the 'color' keyword argument and
the fmt string "k:" (-> color='k'). The keyword argument will take precedence.
  plt.plot([0, v1[0]], [0, v1[1]], 'k:' ,color='b', label='v1', marker='o')
/var/folders/4s/hhswlq455zv2br9bkfsygsfr0000gn/T/ipykernel\_74508/1885378213.py:1
1: UserWarning: color is redundantly defined by the 'color' keyword argument and
the fmt string "k:" (-> color='k'). The keyword argument will take precedence.
  plt.plot([0, v2[0]], [0, v2[1]], 'k:' ,color='g', label='v1', marker='o')
/var/folders/4s/hhswlq455zv2br9bkfsygsfr0000gn/T/ipykernel\_74508/1885378213.py:1
2: UserWarning: color is redundantly defined by the 'color' keyword argument and
the fmt string "k:" (-> color='k'). The keyword argument will take precedence.
  plt.plot([0, v1\_proj\_v2[0]], [0, v1\_proj\_v2[1]], 'k:', color='r', label='v1',
marker='o')
    \end{Verbatim}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{optimizationmethods_files/optimizationmethods_58_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{Verbatim}[commandchars=\\\{\}]
the value of f(x\_1..x\_4)=3x1+5x2-4x3+19x4+3 in x=(3,4,5,1) is 31
    \end{Verbatim}

    \subsubsection{Cross product}\label{cross-product}

The cross product of two vectors is exclusively defined for vectors in
three dimensions. It is denoted with \(\times\), and for vectors
\(\pmb{a} = [a_1, a_2, a_3]\) and \(\pmb{b} = [b_1, b_2, b_3]\), it is
defined as the vector \(\pmb{c}\):

\[
\pmb{c} = \pmb{a} \times \pmb{b} = \begin{bmatrix} a_1 \\ a_2 \\ a_3 \end{bmatrix} \times \begin{bmatrix} b_1 \\ b_2 \\ b_3 \end{bmatrix} = \begin{bmatrix} a_2 b_3 - a_3 b_2 \\ a_3 b_1 - a_1 b_3 \\ a_1 b_2 - a_2 b_1 \end{bmatrix}
\]

Also, the norm of \(\pmb{c} = \pmb{a} \times \pmb{b}\) can be expressed
as a product of the norms of \(\pmb{a}\) and \(\pmb{b}\) and the
\(\sin\) of the angle \(\theta\) between them.

\[
\|\pmb{c}\| = \|\pmb{a} \times \pmb{b}\| = \|\pmb{a}\| \|\pmb{b}\| \sin(\theta)
\]

\emph{Interpretation: In geometry the cross product of two vectors is an
orthogonal vector to the plain that the vectors form, the size of the
vector is the area of the parallelogram formed by the two vectors}

In \texttt{np} the cross product of \texttt{a} and \texttt{b} is
calculated with the function \texttt{np.cross(a,\ b)}.

\textbf{Examples:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Calculate the cross product of the perpendicular vectors
  \texttt{{[}1,\ 0,\ 0{]}}, \texttt{{[}0,\ 1,\ 0{]}}.
\item
  Calculate the cross product of the non-perpendicular non-linear
  dependent vectors \texttt{{[}1,2,3{]}}, \texttt{{[}3,4,5{]}}.
\item
  Calculate the cross product of the linear dependent vectors
  \texttt{{[}1,\ 0,\ 0{]}}, \texttt{{[}5,\ 0,\ 0{]}}.
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{119}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{c+c1}{\PYZsh{} Example 1}
\PY{n}{v1} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
\PY{n}{v2} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
\PY{n}{c} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{cross}\PY{p}{(}\PY{n}{v1}\PY{p}{,} \PY{n}{v2}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Example 1: Cross product of }\PY{l+s+si}{\PYZob{}}\PY{n}{v1}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ and }\PY{l+s+si}{\PYZob{}}\PY{n}{v2}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ = }\PY{l+s+si}{\PYZob{}}\PY{n}{c}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 2}
\PY{n}{v1} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
\PY{n}{v2} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{]}\PY{p}{)}
\PY{n}{c} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{cross}\PY{p}{(}\PY{n}{v1}\PY{p}{,} \PY{n}{v2}\PY{p}{)}

\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Example 2: Cross product of }\PY{l+s+si}{\PYZob{}}\PY{n}{v1}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ and }\PY{l+s+si}{\PYZob{}}\PY{n}{v2}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ = }\PY{l+s+si}{\PYZob{}}\PY{n}{c}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 3}
\PY{n}{v1} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
\PY{n}{v2} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
\PY{n}{c} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{cross}\PY{p}{(}\PY{n}{v1}\PY{p}{,} \PY{n}{v2}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Example 3: Cross product of }\PY{l+s+si}{\PYZob{}}\PY{n}{v1}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ and }\PY{l+s+si}{\PYZob{}}\PY{n}{v2}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ = }\PY{l+s+si}{\PYZob{}}\PY{n}{c}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Example 1: Cross product of [1 0 0] and [0 1 0] = [0 0 1]
Example 2: Cross product of [1 2 3] and [3 4 5] = [-2  4 -2]
Example 3: Cross product of [1 0 0] and [5 0 0] = [0 0 0]
    \end{Verbatim}

    \newpage

\subsubsection{Determinant of a Matrix}\label{determinant-of-a-matrix}

The determinant of a matrix is generally used to solve a system of
linear equations. It is used to determine if the system has a unique
solution, no solution, or infinitely many solutions. Other uses of the
determinant include finding an inverse of for a given matrix. In
general, for a set of vectors, if the determinant is equal to 0, it
indicates that there are at least two vectors that are linearly
dependent.

\texttt{np} uses the formula \texttt{np.linalg.det(A)} to calculate the
determinant of A.

\textbf{Example}: 1. Find the determinant of a matrix of linear
dependent row vectors
\texttt{{[}{[}1,\ 2,\ 3,\ 4{]},\ {[}2,\ 4,\ 6,\ 8{]},\ {[}1,\ 0,\ 1,\ 0{]},\ {[}0,\ 1,\ 0,\ 1{]}{]}}
2. Find the determinant of a matrix of linear independent row vectors:
\texttt{{[}{[}1,\ 2,\ 3,\ 4{]},\ \ \ \ {[}5,\ 7,\ 8,\ 9{]},\ \ \ \ {[}10,\ 11,\ 13,\ 14{]},\ \ \ \ {[}15,\ 16,\ 17,\ 19{]}{]}}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{120}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{c+c1}{\PYZsh{} Example 1}
\PY{n}{dependent\PYZus{}matrix} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}
    \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{]}\PY{p}{,}
    \PY{p}{[}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{]}\PY{p}{,}  \PY{c+c1}{\PYZsh{} This row is 2 times the first row}
    \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
    \PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{]}
\PY{p}{]}\PY{p}{)}

\PY{n}{det\PYZus{}dependent} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linalg}\PY{o}{.}\PY{n}{det}\PY{p}{(}\PY{n}{dependent\PYZus{}matrix}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Determinant of the linearly dependent matrix: }\PY{l+s+si}{\PYZob{}}\PY{n}{det\PYZus{}dependent}\PY{l+s+si}{:}\PY{l+s+s2}{.2f}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 2}
\PY{n}{independent\PYZus{}matrix} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}
\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{]}\PY{p}{,}
    \PY{p}{[}\PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{7}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{,} \PY{l+m+mi}{9}\PY{p}{]}\PY{p}{,}
    \PY{p}{[}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{11}\PY{p}{,} \PY{l+m+mi}{13}\PY{p}{,} \PY{l+m+mi}{14}\PY{p}{]}\PY{p}{,}
    \PY{p}{[}\PY{l+m+mi}{15}\PY{p}{,} \PY{l+m+mi}{16}\PY{p}{,} \PY{l+m+mi}{17}\PY{p}{,} \PY{l+m+mi}{19}\PY{p}{]}
\PY{p}{]}\PY{p}{)}

\PY{n}{det\PYZus{}independent} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linalg}\PY{o}{.}\PY{n}{det}\PY{p}{(}\PY{n}{independent\PYZus{}matrix}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Determinant of the linearly independent matrix: }\PY{l+s+si}{\PYZob{}}\PY{n}{det\PYZus{}independent}\PY{l+s+si}{:}\PY{l+s+s2}{.2f}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Determinant of the linearly dependent matrix: 0.00
Determinant of the linearly independent matrix: -26.00
    \end{Verbatim}

    \subsubsection{Unit/Identity Matrix and Inverse
Matrix}\label{unitidentity-matrix-and-inverse-matrix}

The matrix \(I\) with shape \texttt{{[}n,n{]}} is called an identity
matrix or unite matrix if: \[
I(i,j) =
\begin{cases}
1 & \text{if } i = j \\
0 & \text{if } i \neq j
\end{cases}
\]

\texttt{Numpy} has a build in function for creating an identity matrix
called \texttt{np.identity(\textless{}size\textgreater{})}. The identity
matrix is defined only by the number of the columns or rows. Because of
this \texttt{np.identity(\textless{}size\textgreater{})} only requires
one positive integer to create an identity matrix.

\begin{verbatim}
size = 5
I = np.identity(size)
\end{verbatim}

And an inverse matrix \(A^{-1}\) of \(A\) is a matrix that multiplied
with \(A\) is equal to the inverse matrix \(I\).

\[ A \cdot A^{-1} =  A^{-1} \cdot A = I \]

Finding an inverse matrix for matrix A in np is done with the function
\texttt{inv\_A\ =\ np.linalg.inv(A)}, in case the determinant of \(A\)
is \(0\), \(A\) does not have a inverse matrix and then \(A\) is called
a singular matrix. Calling \texttt{inv\_A\ =\ np.linalg.inv(A)} on a
singular matrix will result in throwing \texttt{np.linalg.LinAlgError}
exception. This behavior results in two possible options, first, before
calling \texttt{inv\_A\ =\ np.linalg.inv(A)} check if the determinant is
0 or second, handle the exception \texttt{np.linalg.LinAlgError}.

Case one:

\begin{verbatim}
det_A = np.linalg.det(A)
if det_A == 0:
 print("Matrix A is singular")
else:
 A_inv = np.linalg.inv(A)
 print("Inverse Matrix of a A is")
 print(A_inv)
\end{verbatim}

Case two:

\begin{verbatim}
try:
 # Step 3: Compute the inverse of A
 A_inv = np.linalg.inv(A)
 print("Inverse Matrix of a A is")
 print(A_inv)
except np.linalg.LinAlgError:
   print("Matrix A is singular")
\end{verbatim}

\newpage

\textbf{Examples:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create identity matrix \texttt{I} with size 5.
\item
  Create random not zero matrix \texttt{A} with shape \texttt{{[}5,5{]}}
  and find the inverse, \texttt{A\_inv} of \texttt{A}.
\item
  Verify that \texttt{A*A\_inv} is equal to the identity \textbf{Use
  \texttt{np.round(A,\ 3)} to round the elements of the matrices to 3
  decimals}.
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{121}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{k}{def} \PY{n+nf}{create\PYZus{}random\PYZus{}square\PYZus{}matrix}\PY{p}{(}\PY{n}{size}\PY{p}{)}\PY{p}{:}
  \PY{n}{A} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{rand}\PY{p}{(}\PY{n}{size}\PY{p}{,} \PY{n}{size}\PY{p}{)}
  \PY{k}{while} \PY{n}{np}\PY{o}{.}\PY{n}{linalg}\PY{o}{.}\PY{n}{det}\PY{p}{(}\PY{n}{A}\PY{p}{)} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
    \PY{n}{A} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{rand}\PY{p}{(}\PY{n}{size}\PY{p}{,} \PY{n}{size}\PY{p}{)}
  \PY{c+c1}{\PYZsh{} returns the matrix only if the determinant is different than 0}
  \PY{k}{return} \PY{n}{A}

\PY{c+c1}{\PYZsh{} Example 1: Create an identity matrix I with size 5}
\PY{n}{I} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{eye}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Identity matrix I:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{I}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 1: Create a random non\PYZhy{}zero matrix A with shape [5, 5]}
\PY{n}{A} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{round}\PY{p}{(}\PY{n}{create\PYZus{}random\PYZus{}square\PYZus{}matrix}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 2: Find the inverse of A (A\PYZus{}inv)}
\PY{n}{A\PYZus{}inv} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{round}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{linalg}\PY{o}{.}\PY{n}{inv}\PY{p}{(}\PY{n}{A}\PY{p}{)}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Random non\PYZhy{}zero matrix A:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{A}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Inverse of matrix A (A\PYZus{}inv):}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{A\PYZus{}inv}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 3: Verify that A * A\PYZus{}inv is equal to the identity matrix}
\PY{n}{A\PYZus{}times\PYZus{}A\PYZus{}inv} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{round}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{dot}\PY{p}{(}\PY{n}{A}\PY{p}{,} \PY{n}{A\PYZus{}inv}\PY{p}{)}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Product of A and A\PYZus{}inv (should be close to identity matrix):}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{A\PYZus{}times\PYZus{}A\PYZus{}inv}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Identity matrix I:
[[1. 0. 0. 0. 0.]
 [0. 1. 0. 0. 0.]
 [0. 0. 1. 0. 0.]
 [0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 1.]]

Random non-zero matrix A:
[[0.65  0.693 0.595 0.507 0.003]
 [0.497 0.688 0.574 0.188 0.082]
 [0.063 0.769 0.777 0.384 0.547]
 [0.629 0.41  0.164 0.587 0.816]
 [0.978 0.56  0.756 0.183 0.219]]

Inverse of matrix A (A\_inv):
[[-0.158  0.408 -0.964  0.414  0.717]
 [-1.148  4.834 -0.836  0.627 -2.043]
 [ 0.805 -3.406  1.607 -1.246  1.894]
 [ 2.808 -3.133  0.491  0.07  -0.351]
 [-1.483  0.196  0.488  0.792  0.346]]

Product of A and A\_inv (should be close to identity matrix):
[[ 1.  0.  0.  0.  0.]
 [ 0.  1.  0.  0.  0.]
 [-0.  0.  1.  0.  0.]
 [ 0.  0.  0.  1.  0.]
 [ 0.  0.  0.  0.  1.]]

    \end{Verbatim}

    \newpage

\subsubsection{Eigenvalue and Eigenvectors of a
matrix}\label{eigenvalue-and-eigenvectors-of-a-matrix}

Given a matrix \(M\), vector \(\pmb{{v}} \ne \mathbf{0}\) and scalar
\(\lambda\) that satisfy the equation
\(M \pmb{{v}} = \lambda \pmb{{v}}\). Then \(\lambda\) is called
eigenvalue of the matrix \(M\) and and \(\pmb{{v}}\) is called
eigenvector of the matrix \(M\) corresponding to the eigenvalue
\(\lambda\).

\emph{Interpretation: Actually, \(\lambda\) and \(\pmb{{v}}\) are such
that the scalar multiple \(\lambda \pmb{{v}}\) and the matrix multiple
\(M\pmb{{v}}\) are one and same vector. In other words, the linear
transformation \(f(\pmb{{v}})=M\pmb{{v}}\) maps the vector \$
\pmb{{v}}\$ in its collinear vector \(\lambda \pmb{{v}}\). It means that
the direction defined by \(\pmb{{v}}\) is invariant under the linear
mapping \(f\).}

\texttt{Numpy} offers an elegant option to calculate the Eigenvalue and
the associated Eigenvectors to the value.

\textbf{Example}: Given a matrix
\texttt{{[}{[}1\ 2\ 3{]}{[}4\ 5\ 6{]}{[}7\ 8\ 9{]}{]}}, find the
Eigenvalues and the corresponding Eigenvectors

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{122}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{n}{A} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{7}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{,} \PY{l+m+mi}{9}\PY{p}{]}\PY{p}{]}\PY{p}{)}

\PY{n}{eigenvalues}\PY{p}{,} \PY{n}{eigenvectors} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linalg}\PY{o}{.}\PY{n}{eig}\PY{p}{(}\PY{n}{A}\PY{p}{)}

\PY{c+c1}{\PYZsh{} iterates the elements in eigenvalues, where index and eigenvalue are the}
\PY{c+c1}{\PYZsh{} index and the appropriate value in every iteration}
\PY{k}{for} \PY{n}{index}\PY{p}{,} \PY{n}{eigenvalue} \PY{o+ow}{in} \PY{n+nb}{enumerate}\PY{p}{(}\PY{n}{eigenvalues}\PY{p}{)}\PY{p}{:}
  \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The eigenvalue }\PY{l+s+si}{\PYZob{}}\PY{n}{eigenvalue}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ has the appropriate eigenvectors }\PY{l+s+si}{\PYZob{}}\PY{n}{eigenvectors}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
The eigenvalue 16.116843969807043 has the appropriate eigenvectors [[-0.23197069
-0.78583024  0.40824829]
 [-0.52532209 -0.08675134 -0.81649658]
 [-0.8186735   0.61232756  0.40824829]]
The eigenvalue -1.1168439698070427 has the appropriate eigenvectors
[[-0.23197069 -0.78583024  0.40824829]
 [-0.52532209 -0.08675134 -0.81649658]
 [-0.8186735   0.61232756  0.40824829]]
The eigenvalue -1.3036777264747022e-15 has the appropriate eigenvectors
[[-0.23197069 -0.78583024  0.40824829]
 [-0.52532209 -0.08675134 -0.81649658]
 [-0.8186735   0.61232756  0.40824829]]
    \end{Verbatim}

    \newpage

\subsubsection{Solving equations}\label{solving-equations}

A system of linear equations can be represented with matrices in the
following form \(A*X=B\).

In mathematics there are multiple ways of solving a system. Python uses
\texttt{numpy.linalg.solve(A,B)}

\textbf{Examples:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Solve the system A*X = B where
  \texttt{A\ ={[}{[}2,\ 3,\ 1{]},{[}4,\ 1,\ 2{]},{[}3,\ 2,\ 3{]}{]}} and
  \texttt{B\ =\ {[}1,\ 2,\ 3{]}} and verify the result.
\item
  Solve the system A*X = B where
  \texttt{A\ =\ {[}{[}1,3,-2{]},{[}3,-2,-1{]}{]}} and
  \texttt{B={[}1,-4{]}}.
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{123}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{c+c1}{\PYZsh{} Example 1}
\PY{n}{A} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}
              \PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}
              \PY{p}{[}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{]}\PY{p}{)}

\PY{n}{B} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
\PY{n}{X} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linalg}\PY{o}{.}\PY{n}{solve}\PY{p}{(}\PY{n}{A}\PY{p}{,}\PY{n}{B}\PY{p}{)}

\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{X = }\PY{l+s+si}{\PYZob{}}\PY{n}{X}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{A*X = }\PY{l+s+si}{\PYZob{}}\PY{n}{np}\PY{o}{.}\PY{n}{dot}\PY{p}{(}\PY{n}{A}\PY{p}{,}\PY{n}{X}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 2}

\PY{n}{A} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\PY{n}{B} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{)}

\PY{n}{X} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linalg}\PY{o}{.}\PY{n}{solve}\PY{p}{(}\PY{n}{A}\PY{p}{,}\PY{n}{B}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
X = [0. 0. 1.]
A*X = [1. 2. 3.]
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}, frame=single, framerule=2mm, rulecolor=\color{outerrorbackground}]
\textcolor{ansi-red}{---------------------------------------------------------------------------}
\textcolor{ansi-red}{LinAlgError}                               Traceback (most recent call last)
Cell \textcolor{ansi-green}{In[123], line 19}
\textcolor{ansi-green-intense}{\textbf{     16}} A \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{=} np\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{.}array([[\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{1},\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{3},\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{-}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{2},\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{1}],[\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{3},\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{-}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{2},\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{-}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{1},\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{-}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{4}]])
\textcolor{ansi-green-intense}{\textbf{     17}} B \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{=} np\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{.}array([\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{1}, \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{-}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{4}])
\textcolor{ansi-green}{---> 19} X \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{=} np\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{.}linalg\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{.}solve(A,B)

File \textcolor{ansi-green}{/opt/anaconda3/lib/python3.12/site-packages/numpy/linalg/linalg.py:396}, in \textcolor{ansi-cyan}{solve}\textcolor{ansi-blue}{(a, b)}
\textcolor{ansi-green-intense}{\textbf{    394}} a, \_ \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{=} \_makearray(a)
\textcolor{ansi-green-intense}{\textbf{    395}} \_assert\_stacked\_2d(a)
\textcolor{ansi-green}{--> 396} \_assert\_stacked\_square(a)
\textcolor{ansi-green-intense}{\textbf{    397}} b, wrap \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{=} \_makearray(b)
\textcolor{ansi-green-intense}{\textbf{    398}} t, result\_t \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{=} \_commonType(a, b)

File \textcolor{ansi-green}{/opt/anaconda3/lib/python3.12/site-packages/numpy/linalg/linalg.py:213}, in \textcolor{ansi-cyan}{\_assert\_stacked\_square}\textcolor{ansi-blue}{(*arrays)}
\textcolor{ansi-green-intense}{\textbf{    211}} m, n \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{=} a\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{.}shape[\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{-}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{2}:]
\textcolor{ansi-green-intense}{\textbf{    212}} \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{0,135,0}}{\textbf{if}} m \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{!=} n:
\textcolor{ansi-green}{--> 213}     \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{0,135,0}}{\textbf{raise}} LinAlgError(\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{175,0,0}}{'}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{175,0,0}}{Last 2 dimensions of the array must be square}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{175,0,0}}{'})

\textcolor{ansi-red}{LinAlgError}: Last 2 dimensions of the array must be square
    \end{Verbatim}

    The system \texttt{A*x\ =\ B} where
\texttt{A\ =\ {[}{[}1,3,-2{]},{[}3,-2,-1{]}{]}} and
\texttt{B={[}1,-4{]}} from the last example cannot be solved with
\texttt{np.linalg.solve(A,\ B)}. This is because
\texttt{np.linalg.solve} expects a square matrix. The solution for this
kind of system is not automated. To solve this system, the Gaussian
Elimination method can be used. The \texttt{custom\_pivot\_column}
function from the next section of exercises can be used to transform a
specified column of a matrix such that all elements in that column are
zero except for the chosen pivot element, which is set to one.

    \newpage

\subsubsection{\texorpdfstring{Exercises with
\texttt{np}}{Exercises with np}}\label{exercises-with-np}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{124}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{c+c1}{\PYZsh{} E. Create an array with size 10, filled with the number 5}
\PY{n}{array} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{full}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{array}\PY{p}{)}

\PY{c+c1}{\PYZsh{} E. add additional 5 zeros to the end of the array}
\PY{n}{array} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{]}
\PY{n}{np}\PY{o}{.}\PY{n}{concatenate}\PY{p}{(}\PY{p}{(}\PY{n}{array}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{full}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{)}\PY{p}{)}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{array}\PY{p}{)}

\PY{c+c1}{\PYZsh{} E. Add a row to matrix}
\PY{n}{matrix} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,}
                   \PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\PY{n}{new\PYZus{}row} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{7}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{,} \PY{l+m+mi}{9}\PY{p}{]}\PY{p}{)}
\PY{n}{matrix\PYZus{}with\PYZus{}new\PYZus{}row} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{vstack}\PY{p}{(}\PY{p}{(}\PY{n}{matrix}\PY{p}{,} \PY{n}{new\PYZus{}row}\PY{p}{)}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Matrix with the new row:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{matrix\PYZus{}with\PYZus{}new\PYZus{}row}\PY{p}{)}

\PY{c+c1}{\PYZsh{} E. Get the number of rows and number of columns of a matrix}
\PY{n}{matrix} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,}
                   \PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{]}\PY{p}{,}
                   \PY{p}{[}\PY{l+m+mi}{7}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{,} \PY{l+m+mi}{9}\PY{p}{]}\PY{p}{]}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Get the number of rows and columns of the matrix}
\PY{n}{num\PYZus{}rows}\PY{p}{,} \PY{n}{num\PYZus{}cols} \PY{o}{=} \PY{n}{matrix}\PY{o}{.}\PY{n}{shape}

\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{num\PYZus{}rows, num\PYZus{}cols = (}\PY{l+s+si}{\PYZob{}}\PY{n}{num\PYZus{}rows}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{,}\PY{l+s+si}{\PYZob{}}\PY{n}{num\PYZus{}cols}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{)}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}


\PY{c+c1}{\PYZsh{} E. Create sub matrix from a given matrix}
\PY{n}{matrix} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,}
                   \PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{]}\PY{p}{,}
                   \PY{p}{[}\PY{l+m+mi}{7}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{,} \PY{l+m+mi}{9}\PY{p}{]}\PY{p}{]}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Get a sub\PYZhy{}matrix from the original matrix}
\PY{c+c1}{\PYZsh{} Define the row and column indices of the sub\PYZhy{}matrix}
\PY{n}{start\PYZus{}row} \PY{o}{=} \PY{l+m+mi}{0}
\PY{n}{end\PYZus{}row} \PY{o}{=} \PY{l+m+mi}{2}  \PY{c+c1}{\PYZsh{} Note: End index is exclusive, so it will include rows up to end\PYZus{}row \PYZhy{} 1}
\PY{n}{start\PYZus{}col} \PY{o}{=} \PY{l+m+mi}{1}
\PY{n}{end\PYZus{}col} \PY{o}{=} \PY{l+m+mi}{3}  \PY{c+c1}{\PYZsh{} Note: End index is exclusive, so it will include columns up to end\PYZus{}col \PYZhy{} 1}

\PY{c+c1}{\PYZsh{} Extract the sub\PYZhy{}matrix using slicing}
\PY{n}{sub\PYZus{}matrix} \PY{o}{=} \PY{n}{matrix}\PY{p}{[}\PY{n}{start\PYZus{}row}\PY{p}{:}\PY{n}{end\PYZus{}row}\PY{p}{,} \PY{n}{start\PYZus{}col}\PY{p}{:}\PY{n}{end\PYZus{}col}\PY{p}{]}

\PY{n+nb}{print}\PY{p}{(}\PY{n}{sub\PYZus{}matrix}\PY{p}{)}

\PY{c+c1}{\PYZsh{} E. From matrix A create matrix B that has the same rows but only the first 4 columns}
\PY{n}{matrix} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{]}\PY{p}{,}
                   \PY{p}{[}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{7}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{9}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{]}\PY{p}{,}
                   \PY{p}{[}\PY{l+m+mi}{11}\PY{p}{,} \PY{l+m+mi}{12}\PY{p}{,} \PY{l+m+mi}{13}\PY{p}{,}\PY{l+m+mi}{14}\PY{p}{,}\PY{l+m+mi}{15}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\PY{n}{sub\PYZus{}matrix} \PY{o}{=} \PY{n}{matrix}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{:}\PY{l+m+mi}{4}\PY{p}{]}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{sub\PYZus{}matrix}\PY{p}{)}


\PY{c+c1}{\PYZsh{} E. From matrix A create matrix B that contains all rows except}
\PY{c+c1}{\PYZsh{} the first one contains the first 4 columns}
\PY{n}{matrix} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{]}\PY{p}{,}
                   \PY{p}{[}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{7}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{9}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{]}\PY{p}{,}
                   \PY{p}{[}\PY{l+m+mi}{11}\PY{p}{,} \PY{l+m+mi}{12}\PY{p}{,} \PY{l+m+mi}{13}\PY{p}{,}\PY{l+m+mi}{14}\PY{p}{,}\PY{l+m+mi}{15}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\PY{n}{sub\PYZus{}matrix} \PY{o}{=} \PY{n}{matrix}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{:}\PY{l+m+mi}{4}\PY{p}{]}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{sub\PYZus{}matrix}\PY{p}{)}

\PY{c+c1}{\PYZsh{} E. Split the matrix A in to two sub matrixes vertically, so that all rows}
\PY{c+c1}{\PYZsh{} from index 0 to 3 will be part of the first sub matrix and all rows from}
\PY{c+c1}{\PYZsh{} index 4 to the end wil lbe part of the second matrix}
\PY{c+c1}{\PYZsh{} the first one contains the first 4 columns}
\PY{n}{matrix} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{]}\PY{p}{,}
                   \PY{p}{[}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{7}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{9}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{]}\PY{p}{,}
                   \PY{p}{[}\PY{l+m+mi}{11}\PY{p}{,} \PY{l+m+mi}{12}\PY{p}{,} \PY{l+m+mi}{13}\PY{p}{,}\PY{l+m+mi}{14}\PY{p}{,}\PY{l+m+mi}{15}\PY{p}{]}\PY{p}{]}\PY{p}{)}

\PY{n}{sub\PYZus{}matrix1} \PY{o}{=} \PY{n}{matrix}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{:}\PY{l+m+mi}{3}\PY{p}{]}
\PY{n}{sub\PYZus{}matrix2} \PY{o}{=} \PY{n}{matrix}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{:}\PY{p}{]}

\PY{c+c1}{\PYZsh{} todo reformat}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{sub\PYZus{}matrix1 = }\PY{l+s+si}{\PYZob{}}\PY{n}{sub\PYZus{}matrix1}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, sub\PYZus{}matrix2 = }\PY{l+s+si}{\PYZob{}}\PY{n}{sub\PYZus{}matrix2}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}


\PY{c+c1}{\PYZsh{} OPERATIONS WITH VECTORS}

\PY{c+c1}{\PYZsh{} E. Vector addition, Sum the two vectors A = (1, 2, 3, 4, 5) and B = (3, 0, 3, 4, 1)}
\PY{n}{a} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{]}\PY{p}{)}
\PY{n}{b} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
\PY{n}{c} \PY{o}{=} \PY{n}{a} \PY{o}{+} \PY{n}{b}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{sum of a =}\PY{l+s+si}{\PYZob{}}\PY{n}{a}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ and b = }\PY{l+s+si}{\PYZob{}}\PY{n}{b}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ is }\PY{l+s+si}{\PYZob{}}\PY{n}{c}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}


\PY{c+c1}{\PYZsh{} E. Inverse matrix, create an inverse matrix for a given matrix A = ([1,2],[5,6])}

\PY{n}{a} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{5}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Inverse of: }\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{a}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{is: }\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n}{A\PYZus{}inverse} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linalg}\PY{o}{.}\PY{n}{inv}\PY{p}{(}\PY{n}{a}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{A\PYZus{}inverse}\PY{p}{)}

\PY{c+c1}{\PYZsh{} E. Inverse matrix, create an inverse matrix for a give matrix A = ([1,2],[5,6]) manually}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Inverse of: }\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{linalg}\PY{o}{.}\PY{n}{det}\PY{p}{(}\PY{n}{a}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
[5 5 5 5 5 5 5 5 5 5]
[1, 2, 3, 4]
Matrix with the new row:
[[1 2 3]
 [4 5 6]
 [7 8 9]]
num\_rows, num\_cols = (3,3)
[[2 3]
 [5 6]]
[[ 1  2  3  4]
 [ 6  7  8  9]
 [11 12 13 14]]
[[ 1  2  3  4]
 [ 6  7  8  9]
 [11 12 13 14]]
sub\_matrix1 = [[ 1  2  3]
 [ 6  7  8]
 [11 12 13]], sub\_matrix2 = [[ 4  5]
 [ 9 10]
 [14 15]]
sum of a =[1 2 3 4 5] and b = [3 0 3 4 1] is [4 2 6 8 6]
Inverse of:
[[1 2]
 [5 6]]
is:
[[-1.5   0.5 ]
 [ 1.25 -0.25]]
Inverse of:
-3.999999999999999
    \end{Verbatim}

    \newpage

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{125}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{}  Pivoting}

\PY{c+c1}{\PYZsh{} In a matrix, pick an element and using linear transformations,}
\PY{c+c1}{\PYZsh{} (multiplying a row with a scalar row and adding it to a different one)}
\PY{c+c1}{\PYZsh{} transform the matrix so that the picked element will be transformed to one and}
\PY{c+c1}{\PYZsh{} all the elements of the matrix in the column of the picked element will be equal}
\PY{c+c1}{\PYZsh{} to 0}
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{k+kn}{from} \PY{n+nn}{sympy} \PY{k+kn}{import} \PY{n}{Matrix}

\PY{k}{def} \PY{n+nf}{custom\PYZus{}pivot\PYZus{}column}\PY{p}{(}\PY{n}{matrix}\PY{p}{,} \PY{n}{pivot\PYZus{}row}\PY{p}{,} \PY{n}{pivot\PYZus{}col}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Convert the matrix to a NumPy array for easier manipulation}
    \PY{n}{np\PYZus{}matrix} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{n}{matrix}\PY{p}{)}

    \PY{c+c1}{\PYZsh{} Divide the pivot row by the pivot element to make it 1}
    \PY{n}{pivot\PYZus{}element} \PY{o}{=} \PY{n}{np\PYZus{}matrix}\PY{p}{[}\PY{n}{pivot\PYZus{}row}\PY{p}{,} \PY{n}{pivot\PYZus{}col}\PY{p}{]}
    \PY{n}{np\PYZus{}matrix}\PY{p}{[}\PY{n}{pivot\PYZus{}row}\PY{p}{,} \PY{p}{:}\PY{p}{]} \PY{o}{/}\PY{o}{=} \PY{n}{pivot\PYZus{}element}

    \PY{c+c1}{\PYZsh{} Eliminate other elements in the same column}
    \PY{n}{num\PYZus{}rows} \PY{o}{=} \PY{n}{np\PYZus{}matrix}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{num\PYZus{}rows}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n}{i} \PY{o}{!=} \PY{n}{pivot\PYZus{}row}\PY{p}{:}
            \PY{n}{ratio} \PY{o}{=} \PY{n}{np\PYZus{}matrix}\PY{p}{[}\PY{n}{i}\PY{p}{,} \PY{n}{pivot\PYZus{}col}\PY{p}{]}
            \PY{n}{np\PYZus{}matrix}\PY{p}{[}\PY{n}{i}\PY{p}{,} \PY{p}{:}\PY{p}{]} \PY{o}{\PYZhy{}}\PY{o}{=} \PY{n}{ratio} \PY{o}{*} \PY{n}{np\PYZus{}matrix}\PY{p}{[}\PY{n}{pivot\PYZus{}row}\PY{p}{,} \PY{p}{:}\PY{p}{]}


    \PY{c+c1}{\PYZsh{} Convert the modified NumPy array back to a SymPy Matrix}
    \PY{n}{pivoted\PYZus{}matrix} \PY{o}{=} \PY{n}{Matrix}\PY{p}{(}\PY{n}{np\PYZus{}matrix}\PY{p}{)}

    \PY{k}{return} \PY{n}{pivoted\PYZus{}matrix}

\PY{n}{m} \PY{o}{=} \PY{n}{Matrix}\PY{p}{(}\PY{p}{[}
    \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}
    \PY{p}{[}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{]}\PY{p}{,}
    \PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{]}\PY{p}{]}\PY{p}{)}

\PY{n+nb}{print}\PY{p}{(}\PY{n}{custom\PYZus{}pivot\PYZus{}column}\PY{p}{(}\PY{n}{m}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{custom\PYZus{}pivot\PYZus{}column}\PY{p}{(}\PY{n}{m}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Matrix([[7/4, 0, 13/4], [3/4, 1, 5/4], [-3/2, 0, 11/2]])
Matrix([[1, -1, 2], [0, 7, -1], [0, 2, 8]])
    \end{Verbatim}

    \newpage

\section{\texorpdfstring{Optimization, approximation algorithms and the
\texttt{scipy.optimize}
library}{Optimization, approximation algorithms and the scipy.optimize library}}\label{optimization-approximation-algorithms-and-the-scipy.optimize-library}

    The following sections of this seminar-work describe different methods
used for finding an extreme or a root of a mathematical function. By
convention this function will be called an \textbf{objective function}.

\textbf{In the following text and code examples, the numerical methods
or optimization methods are referred to as approximation methods and
their results as approximations.}

\textbf{The methods will be explained for the optimization problem of
minimum. In case the maximum of objective function
\(f(x_1, x_2, ... x_n)\) is required, it will be converted to the
problem of minimum of \(- f(x_1, x_2, ... x_n)\).}

All optimization algorithms start with initial list of values called
approximations. The initial values are stored in a problem-specific data
structure using a variable called approximations.

All optimization algorithms are iterative; they define an
algorithm-specific step function. This function is called on the
approximations variable and returns a new approximation. All algorithms
iteratively call the step function on the approximations variable until
a certain condition (stopping criterion) is satisfied.

The general form of an optimization algorithm is presented as follows:

\begin{verbatim}

def approximations = []

def step_function(approximations:list[float]):
 ... <!- calculates a new approximation>
 return approximation

def stop_criterion(approximations:list[float]):
  ...
  return <!-- returns true or false -->

def approximation_method(approximations_in, step_function_in, stop_criterion_in)->list[float]
  while(not stop_criterion_in(approximations[-1])):
    approximation = step_function_in(approximations)
    approximations_in.append(approximation)
  return approximations_in    
\end{verbatim}

The general solution uses an approximations stack/array to store all the
results from the step function. This is not required but is useful for
learning and debugging purposes. For example, investigating intermediate
approximations by printing or visualizing and plotting them.

In Python, the library \texttt{scipy} from the package \texttt{optimize}
can be used to find an approximation to an extreme or a root of a
function. In the following text, I will implement different
approximation methods and also provide the appropriate python function
from \texttt{scipy.optimize}.

    \newpage

\subsection{Golden Search}\label{golden-search}

Golden search method is applicable for a function
\(F: \mathbb{R} \to \mathbb{R}\) on a closed interval \([a_0, b_0]\)
when \(F(x)\) has only one minimum under the closed interval. The
algorithm works in a way that for every step requires a list of four
values for \(x\):

\([a_0, a_1, b_1, b_0]\) so that \(a_0 < a_1 < b_1 < b_0\) and
\(a_1 - a_0 = b_0 - b_1 = p \cdot (b_0 - a_0)\) and \(p < \frac{1}{2}\).

Then it analyzes the function \(F(x)\) at these four values. Depending
on whether \(F(a_1) > F(b_1)\) or \(F(a_1) < F(b_1)\), the minimum will
be located in \([a_0, b_1]\) or in \([a_1, b_0]\). For the two intervals
\([a_0, b_1]\) and \([a_1, b_0]\), three values of \(F(x)\) are already
known or previously calculated: \(F(a_0), F(a_1), F(b_1)\) for
\([a_0, b_1]\) and \(F(a_1), F(b_1), F(b_0)\) for \([a_1, b_0]\). In
order to again analyze \(F\) for a minimum under the new reduced
interval, a new value for \(x\) needs to be picked. \(x\) is picked
using the following optimization:

\(x = a_0 + |a_0 - b_1| \cdot p\) for \([a_0, a_1, b_1]\) resulting in a
new input list of four values for \(x\): \([a_0, x, a_1, b_1]\) where
\(x - a_0 = b_1 - a_1\).

or

\(x = b_0 - |a_1 - b_0| \cdot p\) for \([a_1, b_1, b_0]\) resulting in a
new input list of four values for \(x\): \([a_1, b_1, x, b_0]\) where
\(b_1 - a_1 = b_0 - x\).

The scalar \texttt{p} in the golden search algorithm is optimized and in
every step is equal to:

\[p = \frac{3 - \sqrt{5}}{2} \approx 0.382 \]

The described process is repeated with the new four values for \(x\),
until the is at the required size.

The N-th step reduces the range(uncertainty interval) by factor:

\((1 - p)^N = (0.61803)^N\)

\textbf{Example}: 1. Use the the golden search to find the value of x
that minimizes the function: \(f(x) = x^4 - 14x^3 + 60x^2 + 70x\)
\emph{({[}8{]}, Example 7.1, ``Introduction to Optimization'', page 94)}
2. Use the the golden search
\texttt{minimize\_scalar(f,\ method=\textquotesingle{}golden\textquotesingle{})}
from the library \texttt{scipy}, package \texttt{scipy.optimize} to find
the local minimum of the function

\(f(x) = x^4 - 14x^3 + 60x^2 + 70x\)

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{126}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} tutorial: https://realpython.com/python\PYZhy{}data\PYZhy{}structures/}

\PY{c+c1}{\PYZsh{}Example 1}

\PY{k}{def} \PY{n+nf}{F}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{k}{return} \PY{n}{x\PYZus{}in}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{4}\PY{o}{\PYZhy{}}\PY{l+m+mi}{14}\PY{o}{*}\PY{n}{x\PYZus{}in}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{3}\PY{o}{+}\PY{l+m+mi}{60}\PY{o}{*}\PY{n}{x\PYZus{}in}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{o}{+}\PY{l+m+mi}{70}\PY{o}{*}\PY{n}{x\PYZus{}in}

\PY{c+c1}{\PYZsh{} Approx, Approximations class holds tha values for x\PYZus{}in and calculates f\PYZus{}in for x\PYZus{}in}
\PY{k}{class} \PY{n+nc}{Approx}\PY{p}{:}
 \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{x\PYZus{}in}\PY{p}{,} \PY{n}{f\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{x} \PY{o}{=} \PY{n}{x\PYZus{}in}
  \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}f\PYZus{}x} \PY{o}{=} \PY{k+kc}{None}
  \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{f} \PY{o}{=} \PY{n}{f\PYZus{}in}
 \PY{c+c1}{\PYZsh{} Lazily calculates f\PYZus{}in at execution time and stores, for reuse}
 \PY{n+nd}{@property}
 \PY{k}{def} \PY{n+nf}{f\PYZus{}x}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
    \PY{k}{if}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}f\PYZus{}x} \PY{o}{==} \PY{k+kc}{None}\PY{p}{)}\PY{p}{:}
      \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}f\PYZus{}x} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{f}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{x}\PY{p}{)}
    \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}f\PYZus{}x}

\PY{c+c1}{\PYZsh{} gives the range reduction for two Approximations}
\PY{k}{def} \PY{n+nf}{range\PYZus{}reduction}\PY{p}{(}\PY{n}{a\PYZus{}in}\PY{p}{:}\PY{n}{Approx}\PY{p}{,} \PY{n}{b\PYZus{}in}\PY{p}{:}\PY{n}{Approx}\PY{p}{)}\PY{p}{:}
  \PY{n}{p} \PY{o}{=} \PY{l+m+mf}{0.382}
  \PY{k}{return} \PY{n}{p}\PY{o}{*}\PY{n+nb}{abs}\PY{p}{(}\PY{n}{a\PYZus{}in}\PY{o}{.}\PY{n}{x}\PY{o}{\PYZhy{}}\PY{n}{b\PYZus{}in}\PY{o}{.}\PY{n}{x}\PY{p}{)}

\PY{n}{a0} \PY{o}{=} \PY{n}{Approx}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{F}\PY{p}{)}
\PY{n}{b0} \PY{o}{=} \PY{n}{Approx}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{F}\PY{p}{)}
\PY{n}{a1} \PY{o}{=} \PY{n}{Approx}\PY{p}{(}\PY{n}{a0}\PY{o}{.}\PY{n}{x} \PY{o}{+} \PY{n}{range\PYZus{}reduction}\PY{p}{(}\PY{n}{a0}\PY{p}{,} \PY{n}{b0}\PY{p}{)}\PY{p}{,} \PY{n}{F}\PY{p}{)}
\PY{n}{b1} \PY{o}{=} \PY{n}{Approx}\PY{p}{(}\PY{n}{b0}\PY{o}{.}\PY{n}{x} \PY{o}{\PYZhy{}} \PY{n}{range\PYZus{}reduction}\PY{p}{(}\PY{n}{a0}\PY{p}{,} \PY{n}{b0}\PY{p}{)}\PY{p}{,} \PY{n}{F}\PY{p}{)}

\PY{n}{x\PYZus{}approximations} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{n}{x\PYZus{}approximations}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{p}{(}\PY{n}{a0}\PY{p}{,} \PY{n}{a1}\PY{p}{,} \PY{n}{b1}\PY{p}{,} \PY{n}{b0}\PY{p}{)}\PY{p}{)}

\PY{n}{a0}\PY{p}{,} \PY{n}{a1}\PY{p}{,} \PY{n}{b1}\PY{p}{,} \PY{n}{b0}  \PY{o}{=} \PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}


\PY{k}{def} \PY{n+nf}{golden\PYZus{}search\PYZus{}minimizer\PYZus{}step\PYZus{}function}\PY{p}{(}\PY{n}{f\PYZus{}in}\PY{p}{,} \PY{n}{approximations\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{n}{a0}\PY{p}{,} \PY{n}{a1}\PY{p}{,} \PY{n}{b1}\PY{p}{,} \PY{n}{b0} \PY{o}{=} \PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}
  \PY{k}{if}\PY{p}{(}\PY{n}{a1}\PY{o}{.}\PY{n}{f\PYZus{}x} \PY{o}{\PYZlt{}} \PY{n}{b1}\PY{o}{.}\PY{n}{f\PYZus{}x}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{p}{(}\PY{n}{a0}\PY{p}{,} \PY{n}{Approx}\PY{p}{(}\PY{n}{a0}\PY{o}{.}\PY{n}{x} \PY{o}{+} \PY{n}{range\PYZus{}reduction}\PY{p}{(}\PY{n}{a0}\PY{p}{,}\PY{n}{b1}\PY{p}{)}\PY{p}{,} \PY{n}{f\PYZus{}in}\PY{p}{)}\PY{p}{,} \PY{n}{a1} \PY{p}{,}\PY{n}{b1}\PY{p}{)}
  \PY{k}{else}\PY{p}{:}
    \PY{k}{return} \PY{p}{(}\PY{n}{a1}\PY{p}{,} \PY{n}{b1}\PY{p}{,} \PY{n}{Approx}\PY{p}{(}\PY{n}{b0}\PY{o}{.}\PY{n}{x} \PY{o}{\PYZhy{}} \PY{n}{range\PYZus{}reduction}\PY{p}{(}\PY{n}{a1}\PY{p}{,}\PY{n}{b0}\PY{p}{)}\PY{p}{,} \PY{n}{f\PYZus{}in}\PY{p}{)} \PY{p}{,}\PY{n}{b0}\PY{p}{)}

\PY{k}{def} \PY{n+nf}{golden\PYZus{}search\PYZus{}stop\PYZus{}criterion}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{n}{a0} \PY{o}{=} \PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
  \PY{n}{b0} \PY{o}{=} \PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}
  \PY{k}{return} \PY{n}{b0}\PY{o}{.}\PY{n}{x} \PY{o}{\PYZhy{}} \PY{n}{a0}\PY{o}{.}\PY{n}{x}\PY{o}{\PYZlt{}}\PY{l+m+mf}{0.0001}

\PY{k}{def} \PY{n+nf}{golder\PYZus{}search\PYZus{}method}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{,} \PY{n}{f\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{k}{while}\PY{p}{(}\PY{o+ow}{not} \PY{n}{golden\PYZus{}search\PYZus{}stop\PYZus{}criterion}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{)}\PY{p}{)}\PY{p}{:}
    \PY{n}{current\PYZus{}approx} \PY{o}{=} \PY{n}{golden\PYZus{}search\PYZus{}minimizer\PYZus{}step\PYZus{}function}\PY{p}{(}\PY{n}{f\PYZus{}in}\PY{p}{,} \PY{n}{approximations\PYZus{}in}\PY{p}{)}
    \PY{n}{approximations\PYZus{}in}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{current\PYZus{}approx}\PY{p}{)}
  \PY{k}{return} \PY{n}{approximations\PYZus{}in}

\PY{n}{x\PYZus{}approximations} \PY{o}{=} \PY{n}{golder\PYZus{}search\PYZus{}method}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{,} \PY{n}{F}\PY{p}{)}

\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The minimizer using the manually developed algorithm is equal to X= }\PY{l+s+si}{\PYZob{}}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{x}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Plot}
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{colors} \PY{k}{as} \PY{n+nn}{mcolors}

\PY{n}{x} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{,} \PY{o}{+}\PY{l+m+mf}{0.5}\PY{p}{,} \PY{l+m+mf}{0.01}\PY{p}{)}
\PY{n}{a0\PYZus{}list} \PY{o}{=} \PY{p}{[}\PY{n}{item}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]} \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n}{x\PYZus{}approximations}\PY{p}{]}
\PY{n}{b0\PYZus{}list} \PY{o}{=} \PY{p}{[}\PY{n}{item}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]} \PY{k}{for} \PY{n}{item} \PY{o+ow}{in} \PY{n}{x\PYZus{}approximations}\PY{p}{]}
\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{F}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{)}
\PY{n}{c} \PY{o}{=} \PY{l+m+mi}{0}
\PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n}{x\PYZus{}approximations}\PY{p}{:}
  \PY{n}{plt}\PY{o}{.}\PY{n}{scatter}\PY{p}{(}\PY{n}{i}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{x}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{n}{s}\PY{o}{=}\PY{n+nb}{len}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{n}{c}\PY{p}{)}
  \PY{n}{plt}\PY{o}{.}\PY{n}{scatter}\PY{p}{(}\PY{n}{i}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{x}\PY{p}{,} \PY{n}{i}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{f\PYZus{}x}\PY{p}{,} \PY{n}{s}\PY{o}{=}\PY{n+nb}{len}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{n}{c}\PY{p}{)}
  \PY{n}{c} \PY{o}{=} \PY{n}{c}\PY{o}{+}\PY{l+m+mi}{1}
\PY{n}{plt}\PY{o}{.}\PY{n}{grid}\PY{p}{(}\PY{p}{)}

\PY{c+c1}{\PYZsh{}Example 2}
\PY{k+kn}{from} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{optimize} \PY{k+kn}{import} \PY{n}{minimize\PYZus{}scalar}
\PY{n}{minimizer\PYZus{}python} \PY{o}{=} \PY{n}{minimize\PYZus{}scalar}\PY{p}{(}\PY{n}{F}\PY{p}{,} \PY{n}{method}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{golden}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The minimizer using the minimize\PYZus{}scalar algorithm is equal to X= }\PY{l+s+si}{\PYZob{}}\PY{n}{minimizer\PYZus{}python}\PY{o}{.}\PY{n}{x}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
The minimizer using the manually developed algorithm is equal to X=
-0.49395485895564095
The minimizer using the minimize\_scalar algorithm is equal to X=
-0.4939286751012236
    \end{Verbatim}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{optimizationmethods_files/optimizationmethods_77_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsection{Newton's Method}\label{newtons-method}

The Newton method for minimizing a function \(f(x)\) requires that the
first derivative \(f'(x)\) and the second derivative \(f''(x)\) are
known and also \(f(x)\), \(f'(x)\), \(f''(x)\) can be calculated.

It is given by the iterative formula: \[
x_{k+1} = x_k - \frac{f'(x_k)}{f''(x_k)}
\]

\emph{Interpretation: The Newton method uses a Taylor series function
\(q(x)\) to approximate the objective function at every \(x_k\) value.
By solving \(q'(x)=0\) or \(f'(x_k) + f''(x_k)*(x-x_k)=0\) it finds the
local extreme of the function \(q(x)\). This solution \(x_k+1\) is the
new approximation, and the step is repeated until some stop condition is
reached}

    \textbf{Example}: 1. Manually find the minimizer of
\(f(x) = \frac{1}{2}x^2 - sin(x)\) given the derivatives
\(f'(x) = x - cos(x)\) and \(f''(x) = 1 + sin(x)\), \emph{({[}8{]},
Example 7.3, ``Introduction to Optimization'', page 103)} 2. Use the
\texttt{scipy.optimize.newton} to find the minimizer of
\(f(x) = \frac{1}{2}x^2 - sin(x)\) given the derivatives
\(f'(x) = x - cos(x)\) and \(f''(x) = 1 + sin(x)\), \emph{({[}8{]},
Example 7.3, ``Introduction to Optimization'', page 103)}

    In the following code, several improvements will be implemented:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  All the optimization methods are iterative, they call a specific step
  function until a certain stop\_criterion is reached. This behavior
  will be generalized in the \texttt{general\_approximation\_iterator}
  Python function.
\item
  The approximation method-specific step function will be generated from
  a different specific approximation method builder function and will be
  only dependent on the approximations list.
\item
  The approximation method-specific stop criterion function will be
  generated from a different specific approximation method builder
  function and will be only dependent on the approximations list.
\end{enumerate}

These changes will contribute to more flexibility in creating the
approximation methods. Will alow combining, and reusing the methods.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{c+c1}{\PYZsh{} As all of the approximation methods will have the same interface a}
\PY{c+c1}{\PYZsh{} As all approximation methods will have the same interface,}
\PY{c+c1}{\PYZsh{} a general function can be created that takes any starting values, }
\PY{c+c1}{\PYZsh{} any method\PYZhy{}specific step function, and any stop criterion function, }
\PY{c+c1}{\PYZsh{} and generates an approximation method.}

\PY{k}{def} \PY{n+nf}{general\PYZus{}approximation\PYZus{}iterator}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{,} \PY{n}{stepfunction\PYZus{}in}\PY{p}{,} \PY{n}{stop\PYZus{}criterion\PYZus{}in}\PY{p}{)}\PY{p}{:}
 \PY{k}{while}\PY{p}{(}\PY{o+ow}{not} \PY{n}{stop\PYZus{}criterion\PYZus{}in}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{)}\PY{p}{)}\PY{p}{:}
   \PY{n}{approx} \PY{o}{=} \PY{n}{stepfunction\PYZus{}in}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{)}
   \PY{n}{approximations\PYZus{}in}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{approx}\PY{p}{)}
 \PY{k}{return} \PY{n}{approximations\PYZus{}in}


\PY{c+c1}{\PYZsh{} Example. 1}
\PY{k}{def} \PY{n+nf}{f\PYZus{}derivative\PYZus{}1}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{)}\PY{p}{:}
 \PY{k}{return} \PY{n}{x\PYZus{}in} \PY{o}{\PYZhy{}} \PY{n}{np}\PY{o}{.}\PY{n}{cos}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{)}


\PY{k}{def} \PY{n+nf}{f\PYZus{}derivative\PYZus{}2}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{)}\PY{p}{:}
 \PY{k}{return} \PY{l+m+mi}{1} \PY{o}{+} \PY{n}{np}\PY{o}{.}\PY{n}{sin}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{)}

\PY{n}{x\PYZus{}approximations} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{n}{x\PYZus{}approximations}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{l+m+mf}{0.5}\PY{p}{)}


\PY{k}{def} \PY{n+nf}{step\PYZus{}newtons\PYZus{}method\PYZus{}builder}\PY{p}{(}\PY{n}{f\PYZus{}dv\PYZus{}1\PYZus{}in}\PY{p}{,} \PY{n}{f\PYZus{}dv\PYZus{}2\PYZus{}in}\PY{p}{)}\PY{p}{:}
 \PY{k}{def} \PY{n+nf}{step\PYZus{}function}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{)}\PY{p}{:}
   \PY{n}{der1} \PY{o}{=} \PY{n}{f\PYZus{}dv\PYZus{}1\PYZus{}in}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
   \PY{n}{der2} \PY{o}{=} \PY{n}{f\PYZus{}dv\PYZus{}2\PYZus{}in}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
   \PY{k}{return} \PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{\PYZhy{}} \PY{n}{der1}\PY{o}{/}\PY{n}{der2}
 \PY{k}{return} \PY{n}{step\PYZus{}function}

\PY{k}{def} \PY{n+nf}{stop\PYZus{}criterion\PYZus{}relative\PYZus{}step}\PY{p}{(}\PY{n}{accuracy\PYZus{}in}\PY{p}{:} \PY{n+nb}{float}\PY{p}{)}\PY{p}{:}
 \PY{k}{def} \PY{n+nf}{stop\PYZus{}function}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{)}\PY{p}{:}
   \PY{k}{if}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{)}\PY{o}{\PYZgt{}}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{:}
     \PY{n}{step\PYZus{}size} \PY{o}{=} \PY{n+nb}{abs}\PY{p}{(}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}\PY{o}{/}\PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
     \PY{k}{return} \PY{n}{step\PYZus{}size}\PY{o}{\PYZlt{}}\PY{n}{accuracy\PYZus{}in}
   \PY{k}{return} \PY{k+kc}{False}
 \PY{k}{return} \PY{n}{stop\PYZus{}function}

\PY{k}{def} \PY{n+nf}{newtons\PYZus{}method}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{,} \PY{n}{step\PYZus{}function\PYZus{}in}\PY{p}{,} \PY{n}{stop\PYZus{}criterion\PYZus{}in}\PY{p}{)}\PY{p}{:}
 \PY{k}{return} \PY{n}{general\PYZus{}approximation\PYZus{}iterator}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{,} \PY{n}{step\PYZus{}function\PYZus{}in}\PY{p}{,} \PY{n}{stop\PYZus{}criterion\PYZus{}in}\PY{p}{)}

\PY{n}{step\PYZus{}newtons\PYZus{}method} \PY{o}{=} \PY{n}{step\PYZus{}newtons\PYZus{}method\PYZus{}builder}\PY{p}{(}\PY{n}{f\PYZus{}derivative\PYZus{}1}\PY{p}{,} \PY{n}{f\PYZus{}derivative\PYZus{}2}\PY{p}{)}
\PY{n}{accuracy} \PY{o}{=} \PY{l+m+mf}{0.0000001}
\PY{n}{stop\PYZus{}newtons\PYZus{}method} \PY{o}{=} \PY{n}{stop\PYZus{}criterion\PYZus{}relative\PYZus{}step}\PY{p}{(}\PY{n}{accuracy}\PY{p}{)}

\PY{n}{x\PYZus{}approximations} \PY{o}{=} \PY{n}{newtons\PYZus{}method}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{,} \PY{n}{step\PYZus{}newtons\PYZus{}method}\PY{p}{,} \PY{n}{stop\PYZus{}newtons\PYZus{}method}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Minimizer calculated manually X=}\PY{l+s+si}{\PYZob{}}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example. 2}
\PY{k+kn}{from} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{optimize} \PY{k+kn}{import} \PY{n}{newton}
\PY{n}{root\PYZus{}newton} \PY{o}{=} \PY{n}{newton}\PY{p}{(}\PY{n}{f\PYZus{}derivative\PYZus{}1}\PY{p}{,} \PY{n}{x0}\PY{o}{=}\PY{l+m+mf}{0.5}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Minimizer calculated with scipy.optimize.newton X=}\PY{l+s+si}{\PYZob{}}\PY{n}{root\PYZus{}newton}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Minimizer calculated manually X=0.7390851332151607
Minimizer calculated with scipy.optimize.newton X=0.7390851332151601
    \end{Verbatim}

    Since a function \(f(x)\) has the extreme at the same point where
\(f'(x)\) has value 0. With small modification the Newton's method can
be also used for finding the root of the function \(g(x)=f'(x)\). This
is the iterative formula for finding a root of a function \(g(x)\): \[
x_{k+1} = x_k - \frac{g(x_k)}{g'(x_k)}
\]

\newpage

\textbf{Example}: 1. Manually find the root of the function
\(g(x) = x^3 - 12.2x^2 + 7.45x + 42 = 0\) given its derivative,
\(g'(x) = 3x^2 - 24.4x + 7.45\) using the newton's method.
\emph{({[}8{]}, Example 7.4, ``Introduction to Optimization'', page
105)}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Use the scipy.optimize.newton to find the root of the function \$ g(x)
  = x\^{}3 - 12.2x\^{}2 + 7.45x + 42 = 0 \$ given its derivative,
  \(g'(x) = 3x^2 - 24.4x + 7.45\) using the newton's method.
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{g}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
 \PY{k}{return} \PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{3} \PY{o}{\PYZhy{}} \PY{l+m+mf}{12.2}\PY{o}{*}\PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{+} \PY{l+m+mf}{7.45}\PY{o}{*}\PY{n}{x} \PY{o}{+} \PY{l+m+mi}{42}
\PY{k}{def} \PY{n+nf}{g\PYZus{}derivative}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
 \PY{k}{return} \PY{l+m+mi}{3}\PY{o}{*}\PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{\PYZhy{}} \PY{l+m+mf}{24.4}\PY{o}{*}\PY{n}{x} \PY{o}{+} \PY{l+m+mf}{7.45}

\PY{c+c1}{\PYZsh{} Example 1}
\PY{c+c1}{\PYZsh{} this block uses the previous block functions}
\PY{n}{step\PYZus{}newtons\PYZus{}method} \PY{o}{=} \PY{n}{step\PYZus{}newtons\PYZus{}method\PYZus{}builder}\PY{p}{(}\PY{n}{g}\PY{p}{,} \PY{n}{g\PYZus{}derivative}\PY{p}{)}
\PY{n}{accuracy} \PY{o}{=} \PY{l+m+mf}{0.000001}
\PY{n}{stop\PYZus{}newtons\PYZus{}method} \PY{o}{=} \PY{n}{stop\PYZus{}criterion\PYZus{}relative\PYZus{}step}\PY{p}{(}\PY{n}{accuracy}\PY{p}{)}

\PY{n}{x\PYZus{}approximations} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{n}{x\PYZus{}approximations}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{l+m+mi}{12}\PY{p}{)}
\PY{n}{x\PYZus{}approximations} \PY{o}{=} \PY{n}{newtons\PYZus{}method}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{,} \PY{n}{step\PYZus{}newtons\PYZus{}method}\PY{p}{,} \PY{n}{stop\PYZus{}newtons\PYZus{}method}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Root manually calculated, X=}\PY{l+s+si}{\PYZob{}}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} plot the function and the approximations}
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}
\PY{n}{x\PYZus{}plot} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linspace}\PY{p}{(}\PY{l+m+mf}{10.50}\PY{p}{,} \PY{l+m+mf}{12.1}\PY{p}{,} \PY{l+m+mi}{400}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{scatter}\PY{p}{(}\PY{p}{[}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{x\PYZus{}plot}\PY{p}{,} \PY{n}{g}\PY{p}{(}\PY{n}{x\PYZus{}plot}\PY{p}{)}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{x\PYZus{}plot}\PY{p}{,} \PY{n}{g\PYZus{}derivative}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}\PY{o}{*}\PY{n}{x\PYZus{}plot} \PY{o}{+} \PY{n}{g}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}\PY{o}{\PYZhy{}}\PY{n}{g\PYZus{}derivative}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}\PY{o}{*}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{grid}\PY{p}{(}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 2}
\PY{k+kn}{from} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{optimize} \PY{k+kn}{import} \PY{n}{newton}
\PY{n}{root\PYZus{}newton} \PY{o}{=} \PY{n}{newton}\PY{p}{(}\PY{n}{g}\PY{p}{,} \PY{n}{x0}\PY{o}{=}\PY{l+m+mf}{0.5}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Root calculated with scipy.optimize.newton, X=}\PY{l+s+si}{\PYZob{}}\PY{n}{root\PYZus{}newton}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Root manually calculated, X=11.200000000000093
[12, 11.300375042618478, 11.201895469742569, 11.200000695476783,
11.200000000000093]
    \end{Verbatim}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{optimizationmethods_files/optimizationmethods_83_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{Verbatim}[commandchars=\\\{\}]
Root calculated with scipy.optimize.newton, X=11.199999999999998
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Secant algorithm, Example 7,5 page 107}

\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}
\PY{k+kn}{from} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{optimize} \PY{k+kn}{import} \PY{n}{newton}

\PY{c+c1}{\PYZsh{} Example 1}

\PY{c+c1}{\PYZsh{} Find the root of the function}
\PY{k}{def} \PY{n+nf}{g}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{:}\PY{n+nb}{float}\PY{p}{)}\PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}}\PY{n+nb}{float}\PY{p}{:}
  \PY{k}{return} \PY{n}{x\PYZus{}in}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{3} \PY{o}{\PYZhy{}} \PY{l+m+mf}{12.2}\PY{o}{*}\PY{n}{x\PYZus{}in}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{+} \PY{l+m+mf}{7.45}\PY{o}{*}\PY{n}{x\PYZus{}in} \PY{o}{+} \PY{l+m+mi}{42}

\PY{c+c1}{\PYZsh{} Plot}
\PY{n}{x\PYZus{}plot} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linspace}\PY{p}{(}\PY{l+m+mf}{8.8}\PY{p}{,} \PY{l+m+mi}{13}\PY{p}{,} \PY{l+m+mi}{100}\PY{p}{)}
\PY{c+c1}{\PYZsh{} Generate data}
\PY{n}{x\PYZus{}plot} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linspace}\PY{p}{(}\PY{l+m+mf}{8.8}\PY{p}{,} \PY{l+m+mi}{13}\PY{p}{,} \PY{l+m+mi}{100}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Create the plot}
\PY{n}{fig}\PY{p}{,} \PY{n}{ax} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{subplots}\PY{p}{(}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Plot the data}
\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{x\PYZus{}plot}\PY{p}{,} \PY{n}{g}\PY{p}{(}\PY{n}{x\PYZus{}plot}\PY{p}{)}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{grid}\PY{p}{(}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Show the plot}
\PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}

\PY{k}{def} \PY{n+nf}{secant\PYZus{}method\PYZus{}step\PYZus{}builder}\PY{p}{(}\PY{n}{f\PYZus{}in}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{step\PYZus{}function}\PY{p}{(}\PY{n}{x\PYZus{}approximations\PYZus{}in}\PY{p}{)}\PY{p}{:}
      \PY{n}{\PYZus{}a} \PY{o}{=} \PY{p}{(}\PY{n}{f\PYZus{}in}\PY{p}{(}\PY{n}{x\PYZus{}approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{o}{*}\PY{n}{x\PYZus{}approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{]} \PY{o}{\PYZhy{}} \PY{n}{f\PYZus{}in}\PY{p}{(}\PY{n}{x\PYZus{}approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}\PY{o}{*}\PY{n}{x\PYZus{}approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
      \PY{n}{\PYZus{}b} \PY{o}{=} \PY{p}{(}\PY{n}{f\PYZus{}in}\PY{p}{(}\PY{n}{x\PYZus{}approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{n}{f\PYZus{}in}\PY{p}{(}\PY{n}{x\PYZus{}approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}\PY{p}{)}
      \PY{k}{return} \PY{n}{\PYZus{}a}\PY{o}{/}\PY{n}{\PYZus{}b}
    \PY{k}{return} \PY{n}{step\PYZus{}function}


\PY{k}{def} \PY{n+nf}{secant\PYZus{}method}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{,} \PY{n}{function\PYZus{}in}\PY{p}{,} \PY{n}{stop\PYZus{}criterion\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{k}{return} \PY{n}{general\PYZus{}approximation\PYZus{}iterator}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{,}
                                    \PY{n}{secant\PYZus{}method\PYZus{}step\PYZus{}builder}\PY{p}{(}\PY{n}{function\PYZus{}in}\PY{p}{)}\PY{p}{,}
                                    \PY{n}{stop\PYZus{}criterion\PYZus{}in}\PY{p}{)}

\PY{n}{x\PYZus{}approximations} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{n}{x\PYZus{}approximations}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{l+m+mi}{13}\PY{p}{)}
\PY{n}{x\PYZus{}approximations}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{l+m+mi}{12}\PY{p}{)}

\PY{n}{stop\PYZus{}criterion\PYZus{}secant} \PY{o}{=} \PY{n}{stop\PYZus{}criterion\PYZus{}relative\PYZus{}step}\PY{p}{(}\PY{l+m+mf}{1e\PYZhy{}12}\PY{p}{)}

\PY{n}{secant\PYZus{}method}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{,} \PY{n}{g} \PY{p}{,} \PY{n}{stop\PYZus{}criterion\PYZus{}secant}\PY{p}{)}

\PY{k}{for} \PY{n}{element} \PY{o+ow}{in} \PY{n+nb}{enumerate}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Step }\PY{l+s+si}{\PYZob{}}\PY{n}{element}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ approximation value }\PY{l+s+si}{\PYZob{}}\PY{n}{element}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{,}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 2}
\PY{k+kn}{from} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{optimize} \PY{k+kn}{import} \PY{n}{newton}
\PY{c+c1}{\PYZsh{} x0 x1 are the two starting values for secant method}
\PY{n}{root\PYZus{}secant} \PY{o}{=} \PY{n}{newton}\PY{p}{(}\PY{n}{g}\PY{p}{,} \PY{n}{x0}\PY{o}{=}\PY{l+m+mi}{13}\PY{p}{,} \PY{n}{x1}\PY{o}{=}\PY{l+m+mi}{12}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Root found by scipy.optimize.newton Secant method:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{root\PYZus{}secant}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{optimizationmethods_files/optimizationmethods_84_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{Verbatim}[commandchars=\\\{\}]
Step 0 approximation value 13,
Step 1 approximation value 12,
Step 2 approximation value 11.401574803149607,
Step 3 approximation value 11.227209417308144,
Step 4 approximation value 11.201027680731215,
Step 5 approximation value 11.200005393481776,
Step 6 approximation value 11.200000001073377,
Step 7 approximation value 11.2,
Step 8 approximation value 11.2,
Root found by scipy.optimize.newton Secant method: 11.200000000000033
    \end{Verbatim}

    \newpage

\subsection{Gradient method}\label{gradient-method}

The Gradient method is used to approximate an extremum of a function
\(f\). Similar to the Newton method, it requires the knowledge of the
derivative of \(f\) in the approximation steps
\(\pmb{x^{(0)}}, \pmb{x^{(1)}}...\) .

\begin{itemize}
\item
  Given \(f(\pmb{x}) = c, \pmb{x} \in \pmb{R}^n\), and \$ c
  \in \pmb{R}\$.
\item
  The gradient of \(f\) at \(\pmb{x_0}\) is a vector in
  \(\textbf{R}^n\), denoted by \(\nabla f(\pmb{x_0})\).
\item
  \(\nabla f(\pmb{x_0})\) points in the direction of the maximum rate of
  increase of \(f(\pmb{x})\).
\item
  \(-\nabla f(\pmb{x_0})\) points in the direction of the maximum rate
  of decrease of \(f(\pmb{x})\).
\end{itemize}

For a starting value \(\pmb{x^{(k_0)}}\), the value \(\pmb{x^{(k+1)}}\)
will be a ``move'' in the direction of the local minimum:

\[
\pmb{x^{(k+1)}} = \pmb{x^{(k)}} - \alpha_k \nabla f(\pmb{x^{(k)}})
\]

For a starting the value \(x\pmb{^{(k_0)}}\), the value
\(\pmb{x^{(k+1)}}\) will be a ``move'' in the direction of the local
maximum:

\[
\pmb{x^{(k+1)}} = \pmb{x^{(k)}} + \alpha_k \nabla f(\pmb{x^{(k)}})
\]

The scalar \(\alpha_k\) is the \(\textit{step size}\) and is always
bigger than 0. Different variations of the algorithm exist, that use
different strategies to re-calculated \(\alpha\) on every iteration.
Correctly choosing \(\alpha\) is quite important, picking a random
\(\alpha\) might not result in convergence.

Unlike the previous example, where approximation was done on a
one-dimensional function, the following gradient method algorithm
approximates an n-dimensional function. As a result, the steps
\(\pmb{x^{(0)}}, \pmb{x^{(1)}}, \ldots\) are n-dimensional dots/vectors.
Consequently, the algorithm stops when the distance between
\(\pmb{x^{(k)}}\) and \(\pmb{x^{(k+1)}}\) is smaller than a given
accuracy, or when the norm of the vector
\(\| \pmb{x^{(k)}} - \pmb{x^{(k+1)}} \|\) is smaller than a required
accuracy.

\textbf{Example}. Find the minimizer of
\(f(x_1, x_2, x_3) = (x_1 - 4)^4 + (x_2 - x_3)^2 + 4(x_3 + 5)^4\),
\emph{({[}8{]}, Page 118, Example 8.1, ``An Introduction to
Optimization'')}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{130}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Gradient method with fixed step alfa}
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}

\PY{c+c1}{\PYZsh{} Example 1}

\PY{k}{def} \PY{n+nf}{f}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{4}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{4} \PY{o}{+} \PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{3}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{+} \PY{l+m+mi}{4}\PY{o}{*}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{+}\PY{l+m+mi}{5}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{4}

\PY{k}{def} \PY{n+nf}{delta\PYZus{}f}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{4}\PY{o}{*}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{4}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{2}\PY{o}{*}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{16}\PY{o}{*}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{+}\PY{l+m+mi}{5}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}

\PY{k}{def} \PY{n+nf}{gradient\PYZus{}method\PYZus{}step\PYZus{}builder}\PY{p}{(}\PY{n}{delta\PYZus{}f\PYZus{}in}\PY{p}{,} \PY{n}{alfa\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{k}{def} \PY{n+nf}{step\PYZus{}function}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{\PYZhy{}} \PY{n}{alfa\PYZus{}in}\PY{o}{*}\PY{n}{delta\PYZus{}f\PYZus{}in}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
  \PY{k}{return} \PY{n}{step\PYZus{}function}

\PY{k}{def} \PY{n+nf}{gradient\PYZus{}method}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{,} \PY{n}{function\PYZus{}in}\PY{p}{,} \PY{n}{stop\PYZus{}criterion\PYZus{}in}\PY{p}{,} \PY{n}{alfa\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{k}{return} \PY{n}{general\PYZus{}approximation\PYZus{}iterator}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{,}
                                    \PY{n}{gradient\PYZus{}method\PYZus{}step\PYZus{}builder}\PY{p}{(}\PY{n}{function\PYZus{}in}\PY{p}{,}
                                                                 \PY{n}{alfa\PYZus{}in}\PY{p}{)}\PY{p}{,}
                                    \PY{n}{stop\PYZus{}criterion\PYZus{}in}\PY{p}{)}

\PY{k}{def} \PY{n+nf}{stop\PYZus{}criteria\PYZus{}relative\PYZus{}multi\PYZus{}dimensional}\PY{p}{(}\PY{n}{accuracy\PYZus{}in}\PY{p}{:}\PY{n+nb}{float}\PY{p}{)}\PY{p}{:}
  \PY{k}{def} \PY{n+nf}{stop\PYZus{}criterion}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{:} \PY{n+nb}{list}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mi}{1}\PY{p}{:}
      \PY{n}{a\PYZus{}} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linalg}\PY{o}{.}\PY{n}{norm}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{\PYZhy{}} \PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}
      \PY{n}{b\PYZus{}} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linalg}\PY{o}{.}\PY{n}{norm}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}
      \PY{k}{return} \PY{p}{(}\PY{n}{a\PYZus{}}\PY{o}{/}\PY{n+nb}{min}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{b\PYZus{}}\PY{p}{)}\PY{p}{)}\PY{o}{\PYZlt{}}\PY{n}{accuracy\PYZus{}in}
    \PY{k}{return} \PY{k+kc}{False}
  \PY{k}{return} \PY{n}{stop\PYZus{}criterion}

\PY{n}{x\PYZus{}approximations} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{n}{x0} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
\PY{n}{x\PYZus{}approximations}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{x0}\PY{p}{)}

\PY{n}{approximations\PYZus{}gradient} \PY{o}{=} \PY{n}{gradient\PYZus{}method}\PY{p}{(}\PY{n}{approximations\PYZus{}in} \PY{o}{=} \PY{n}{x\PYZus{}approximations}\PY{p}{,}
                                          \PY{n}{function\PYZus{}in} \PY{o}{=} \PY{n}{delta\PYZus{}f}\PY{p}{,}
                                          \PY{n}{stop\PYZus{}criterion\PYZus{}in} \PY{o}{=} \PY{n}{stop\PYZus{}criteria\PYZus{}relative\PYZus{}multi\PYZus{}dimensional}\PY{p}{(}\PY{n}{accuracy\PYZus{}in} \PY{o}{=} \PY{l+m+mf}{0.00001}\PY{p}{)}\PY{p}{,}
                                          \PY{n}{alfa\PYZus{}in} \PY{o}{=} \PY{l+m+mf}{0.00001}\PY{p}{)}

\PY{c+c1}{\PYZsh{} The algorithm is not really efficient as alpha is fixed}
\PY{c+c1}{\PYZsh{} and conservatively selected.}
\PY{c+c1}{\PYZsh{} The following code prints every 1000 approximation}
\PY{k}{for} \PY{n}{i}\PY{p}{,} \PY{n}{element} \PY{o+ow}{in} \PY{n+nb}{enumerate}\PY{p}{(}\PY{n}{approximations\PYZus{}gradient}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{i} \PY{o}{\PYZpc{}} \PY{l+m+mi}{1000} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{    }\PY{l+s+si}{\PYZob{}}\PY{n}{element}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{,}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The algorithm achieved accuracy of }\PY{l+s+si}{\PYZob{}}\PY{n}{accuracy}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ in }\PY{l+s+si}{\PYZob{}}\PY{n+nb}{len}\PY{p}{(}\PY{n}{approximations\PYZus{}gradient}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ steps}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
    [ 4  2 -1],
    [ 4.          2.01980152 -3.38401547],
    [ 4.          2.03921095 -3.80739339],
    [ 4.          2.05823603 -4.01138817],
    [ 4.          2.07688439 -4.13717301],
    [ 4.          2.09516349 -4.22461701],
    [ 4.          2.11308063 -4.28992785],
    [ 4.          2.13064298 -4.34110152],
    [ 4.          2.14785757 -4.3825981 ],
    [ 4.          2.16473129 -4.41712757],
    [ 4.          2.18127088 -4.44644404],
    [ 4.          2.19748297 -4.4717397 ],
    [ 4.          2.21337403 -4.49385691],
    [ 4.          2.22895042 -4.51341003],
    [ 4.          2.24421837 -4.53085906],
    [ 4.          2.259184   -4.54655616],
    [ 4.          2.27385329 -4.56077616],
    [ 4.          2.2882321  -4.57373709],
    [ 4.          2.30232619 -4.58561441],
    [ 4.          2.31614119 -4.59655115],
    [ 4.          2.32968264 -4.60666527],
    [ 4.          2.34295594 -4.61605495],
    [ 4.          2.35596641 -4.62480276],
    [ 4.          2.36871926 -4.63297864],
    [ 4.          2.38121958 -4.64064231],
    [ 4.          2.39347237 -4.64784512],
    [ 4.          2.40548254 -4.65463148],
    [ 4.          2.41725489 -4.66104003],
    [ 4.          2.42879413 -4.66710458],
    [ 4.          2.44010488 -4.67285484],
    [ 4.          2.45119166 -4.67831705],
    [ 4.          2.4620589  -4.68351448],
    [ 4.          2.47271095 -4.68846786],
    [ 4.          2.48315208 -4.69319571],
    [ 4.          2.49338645 -4.69771464],
    [ 4.          2.50341817 -4.7020396 ],
    [ 4.          2.51325125 -4.70618407],
    [ 4.          2.52288962 -4.71016027],
    [ 4.          2.53233713 -4.71397929],
The algorithm achieved accuracy of 1e-06 in 38331 steps
    \end{Verbatim}

    \subsection{Gradient with step adjustment, Steepest
descent}\label{gradient-with-step-adjustment-steepest-descent}

In-order to optimize \(\alpha_k\) when minimizing \(f\), it is requeued
to finding a positive \(\alpha_k\) so for the next \(\pmb{x^{(k+1)}}\),
\(\pmb{x^{(k+1)}} = \pmb{x^{(k)}} - \alpha_k \nabla f(\pmb{x^{(k)}})\)
the function \(f(\pmb{x^{(k+1)}})\) will have the smallest possible
value.

Since the vectors/dots, \(\pmb{x^{(k)}}\) and
\(\nabla f(\pmb{x^{(k)}})\) are already know, optimizing \(\alpha_k\)
would be finding a minimum of the one dimensional function:
\[argmin(\alpha_k) = f(\pmb{x^{(k)}} - \alpha_k \nabla f(\pmb{x^{(k)}}))\]

The minimizer of \(argmin(\alpha_k)\) can be found using some of the
previous approximation methods that are applicable on one dimensional
functions.

\textbf{Examples:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Develop an algorithm for the Steepest descent method and find the
  minimizer of
  \(f(x_1, x_2, x_3) = (x_1 - 4)^4 + (x_2 - x_3)^2 + 4(x_3 + 5)^4\)
  where the step \(\alpha_k\) is adjusted using the secant\_method
  method, \emph{({[}8{]}, Page 118, Example 8.1 of ``An Introduction to
  Optimization'')}.
\item
  Find the minimizer of
  \(f(x_1, x_2, x_3) = (x_1 - 4)^4 + (x_2 - x_3)^2 + 4(x_3 + 5)^4\)
  using the python's \texttt{minimize} from the
  \texttt{scipy.optimize\ import\ minimize}, \emph{({[}8{]}, Page 118,
  Example 8.1 of ``An Introduction to Optimization'')}.
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Gradient with step adjustment alpha or Steepest descent}

\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{k}{def} \PY{n+nf}{f}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{n+nb}{float}\PY{p}{:}
    \PY{k}{return} \PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{4}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{4} \PY{o}{+} \PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{3}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{+} \PY{l+m+mi}{4}\PY{o}{*}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{+}\PY{l+m+mi}{5}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{4}

\PY{k}{def} \PY{n+nf}{delta\PYZus{}f}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{4}\PY{o}{*}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{4}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{2}\PY{o}{*}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{16}\PY{o}{*}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{+}\PY{l+m+mi}{5}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}

\PY{c+c1}{\PYZsh{} This structure creates the arg\PYZus{}min initially dependent on the objective}
\PY{c+c1}{\PYZsh{} function function\PYZus{}in and then on the current approximation of function\PYZus{}in}
\PY{c+c1}{\PYZsh{} in the respective iteration.}
\PY{k}{def} \PY{n+nf}{arg\PYZus{}min\PYZus{}builder}\PY{p}{(}\PY{n}{function\PYZus{}in}\PY{p}{,} \PY{n}{delta\PYZus{}function\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{k}{def} \PY{n+nf}{alpha\PYZus{}arg\PYZus{}min\PYZus{}approximation}\PY{p}{(}\PY{n}{current\PYZus{}approximation\PYZus{}in}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{arg\PYZus{}min}\PY{p}{(}\PY{n}{alpha\PYZus{}in}\PY{p}{:} \PY{n+nb}{float}\PY{p}{)}\PY{p}{:}
      \PY{n}{delta\PYZus{}x} \PY{o}{=} \PY{n}{delta\PYZus{}function\PYZus{}in}\PY{p}{(}\PY{n}{current\PYZus{}approximation\PYZus{}in}\PY{p}{)}
      \PY{n}{alpha\PYZus{}delta} \PY{o}{=} \PY{n}{alpha\PYZus{}in}\PY{o}{*}\PY{n}{delta\PYZus{}x}
      \PY{k}{return} \PY{n}{function\PYZus{}in}\PY{p}{(}\PY{n}{current\PYZus{}approximation\PYZus{}in}\PY{o}{\PYZhy{}}\PY{n}{alpha\PYZus{}delta}\PY{p}{)}
    \PY{k}{return} \PY{n}{arg\PYZus{}min}
  \PY{k}{return} \PY{n}{alpha\PYZus{}arg\PYZus{}min\PYZus{}approximation}

\PY{c+c1}{\PYZsh{} The derivate is used to approximate the alpha}
\PY{k}{def} \PY{n+nf}{derivative\PYZus{}of}\PY{p}{(}\PY{n}{function\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{k}{def} \PY{n+nf}{numerical\PYZus{}derivative}\PY{p}{(}\PY{n}{x\PYZus{}in}\PY{p}{)}\PY{p}{:}
    \PY{n}{\PYZus{}delta\PYZus{}x} \PY{o}{=} \PY{l+m+mf}{1e\PYZhy{}5}
    \PY{n}{\PYZus{}derivate\PYZus{}f} \PY{o}{=} \PY{p}{(}\PY{n}{function\PYZus{}in}\PY{p}{(}\PY{n}{x\PYZus{}in} \PY{o}{+} \PY{n}{\PYZus{}delta\PYZus{}x}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{n}{function\PYZus{}in}\PY{p}{(}\PY{n}{x\PYZus{}in} \PY{o}{\PYZhy{}} \PY{n}{\PYZus{}delta\PYZus{}x}\PY{p}{)}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{\PYZus{}delta\PYZus{}x}\PY{p}{)}
    \PY{k}{return} \PY{n}{\PYZus{}derivate\PYZus{}f}
  \PY{k}{return} \PY{n}{numerical\PYZus{}derivative}

\PY{c+c1}{\PYZsh{} Let\PYZsq{}s create a general function that will take an approximation\PYZus{}method from the methods we have previously defined,}
\PY{c+c1}{\PYZsh{} the approximations\PYZus{}in, and the stop\PYZus{}criterion\PYZus{}in. It will return an approximation\PYZus{}method function that will be able to}
\PY{c+c1}{\PYZsh{} approximate any input function given the approximation\PYZus{}method\PYZus{}in, approximations\PYZus{}in, and stop\PYZus{}criterion\PYZus{}in.}
\PY{k}{def} \PY{n+nf}{approximation\PYZus{}method\PYZus{}builder}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{,} \PY{n}{approximation\PYZus{}method\PYZus{}in}\PY{p}{,} \PY{n}{stop\PYZus{}criterion\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{k}{def} \PY{n+nf}{approximation\PYZus{}method}\PY{p}{(}\PY{n}{function\PYZus{}in}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{approximation\PYZus{}method\PYZus{}in}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{n}{function\PYZus{}in}\PY{p}{,} \PY{n}{stop\PYZus{}criterion\PYZus{}in}\PY{p}{)}
  \PY{k}{return} \PY{n}{approximation\PYZus{}method}

\PY{c+c1}{\PYZsh{} Here Im defining a step function for the gradient method with adjustable alpha step}
\PY{c+c1}{\PYZsh{} This function already uses the gradient\PYZus{}method\PYZus{}step\PYZus{}builder function with fixed alpha}
\PY{c+c1}{\PYZsh{} and approximates alpha based on the}
\PY{k}{def} \PY{n+nf}{gradient\PYZus{}method\PYZus{}step\PYZus{}builder\PYZus{}with\PYZus{}adjustable\PYZus{}alpha}\PY{p}{(}\PY{n}{f\PYZus{}in}\PY{p}{,} \PY{n}{delta\PYZus{}f\PYZus{}in}\PY{p}{,} \PY{n}{alpha\PYZus{}approximation\PYZus{}method\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{n}{alpha\PYZus{}arg\PYZus{}min\PYZus{}builder\PYZus{}from\PYZus{}approximation} \PY{o}{=} \PY{n}{arg\PYZus{}min\PYZus{}builder}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{n}{delta\PYZus{}f}\PY{p}{)}
  \PY{k}{def} \PY{n+nf}{approximate\PYZus{}alpha}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{)}\PY{p}{:}
    \PY{n}{alpha\PYZus{}arg\PYZus{}min\PYZus{}function\PYZus{}} \PY{o}{=} \PY{n}{alpha\PYZus{}arg\PYZus{}min\PYZus{}builder\PYZus{}from\PYZus{}approximation}\PY{p}{(}\PY{n}{current\PYZus{}approximation\PYZus{}in} \PY{o}{=} \PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
    \PY{n}{derivative\PYZus{}alpha\PYZus{}function} \PY{o}{=} \PY{n}{derivative\PYZus{}of}\PY{p}{(}\PY{n}{alpha\PYZus{}arg\PYZus{}min\PYZus{}function\PYZus{}}\PY{p}{)}
    \PY{n}{alpha\PYZus{}approximations} \PY{o}{=} \PY{n}{alpha\PYZus{}approximation\PYZus{}method\PYZus{}in}\PY{p}{(}\PY{n}{derivative\PYZus{}alpha\PYZus{}function}\PY{p}{)}
    \PY{n}{alpha} \PY{o}{=} \PY{n}{alpha\PYZus{}approximations}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}
    \PY{k}{return} \PY{n}{alpha}
  \PY{k}{def} \PY{n+nf}{step\PYZus{}function}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{)}\PY{p}{:}
    \PY{n}{alpha} \PY{o}{=} \PY{n}{approximate\PYZus{}alpha}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{)}
    \PY{n}{gradient\PYZus{}step\PYZus{}function} \PY{o}{=} \PY{n}{gradient\PYZus{}method\PYZus{}step\PYZus{}builder}\PY{p}{(}\PY{n}{delta\PYZus{}f\PYZus{}in}\PY{p}{,} \PY{n}{alpha}\PY{p}{)}
    \PY{k}{return} \PY{n}{gradient\PYZus{}step\PYZus{}function}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{)}
  \PY{k}{return} \PY{n}{step\PYZus{}function}

\PY{k}{def} \PY{n+nf}{gradient\PYZus{}method\PYZus{}with\PYZus{}alpha\PYZus{}adjustment}\PY{p}{(}\PY{n}{f\PYZus{}in}\PY{p}{,}
                                          \PY{n}{delta\PYZus{}f\PYZus{}in}\PY{p}{,}
                                          \PY{n}{approximations\PYZus{}in}\PY{p}{,}
                                          \PY{n}{stop\PYZus{}criterion\PYZus{}in}\PY{p}{,}
                                          \PY{n}{alpha\PYZus{}approximation\PYZus{}method\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{k}{return} \PY{n}{general\PYZus{}approximation\PYZus{}iterator}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{,}
                             \PY{n}{gradient\PYZus{}method\PYZus{}step\PYZus{}builder\PYZus{}with\PYZus{}adjustable\PYZus{}alpha}\PY{p}{(}
                                 \PY{n}{f\PYZus{}in}\PY{p}{,}
                                 \PY{n}{delta\PYZus{}f\PYZus{}in}\PY{p}{,}
                                 \PY{n}{alpha\PYZus{}approximation\PYZus{}method\PYZus{}in}
                             \PY{p}{)}\PY{p}{,}
                             \PY{n}{stop\PYZus{}criterion\PYZus{}in}\PY{p}{)}

\PY{n}{x0} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
\PY{n}{x\PYZus{}approximations} \PY{o}{=} \PY{p}{[}\PY{n}{x0}\PY{p}{]}

\PY{n}{gradient\PYZus{}method\PYZus{}with\PYZus{}alpha\PYZus{}adjustment}\PY{p}{(}\PY{n}{f\PYZus{}in} \PY{o}{=} \PY{n}{f}\PY{p}{,}
                                      \PY{n}{delta\PYZus{}f\PYZus{}in} \PY{o}{=} \PY{n}{delta\PYZus{}f}\PY{p}{,}
                                      \PY{n}{approximations\PYZus{}in} \PY{o}{=} \PY{n}{x\PYZus{}approximations}\PY{p}{,}
                                      \PY{n}{stop\PYZus{}criterion\PYZus{}in} \PY{o}{=} \PY{n}{stop\PYZus{}criteria\PYZus{}relative\PYZus{}multi\PYZus{}dimensional}\PY{p}{(}\PY{n}{accuracy\PYZus{}in}\PY{o}{=}\PY{l+m+mf}{0.00001}\PY{p}{)}\PY{p}{,}
                                      \PY{n}{alpha\PYZus{}approximation\PYZus{}method\PYZus{}in} \PY{o}{=} \PY{n}{approximation\PYZus{}method\PYZus{}builder}\PY{p}{(}
                                        \PY{n}{approximations\PYZus{}in} \PY{o}{=} \PY{p}{[}\PY{l+m+mf}{0.01}\PY{p}{,} \PY{l+m+mf}{0.08}\PY{p}{]}\PY{p}{,}
                                        \PY{n}{approximation\PYZus{}method\PYZus{}in} \PY{o}{=} \PY{n}{secant\PYZus{}method}\PY{p}{,}
                                        \PY{n}{stop\PYZus{}criterion\PYZus{}in} \PY{o}{=} \PY{n}{stop\PYZus{}criterion\PYZus{}relative\PYZus{}step}\PY{p}{(}\PY{l+m+mf}{0.0001}\PY{p}{)}
                                      \PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Print the result}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The minimum of f using the manually written algorithm is in }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
      \PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ and the minimum value is : }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
      \PY{n}{f}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Example 2}
\PY{k+kn}{from} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{optimize} \PY{k+kn}{import} \PY{n}{minimize}

\PY{c+c1}{\PYZsh{} The method minimize is a general method for minimizing a function f given its}
\PY{c+c1}{\PYZsh{} gradient delta\PYZus{}f, it is not strictly using the steepest descent algorithm}
\PY{c+c1}{\PYZsh{} In this case `method=\PYZsq{}Newton\PYZhy{}CG\PYZsq{} the minimize function will use the Newton\PYZhy{}CG algorithm}
\PY{c+c1}{\PYZsh{} https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html\PYZsh{}scipy.optimize.minimize}
\PY{n}{result} \PY{o}{=} \PY{n}{minimize}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{n}{x0}\PY{p}{,} \PY{n}{method}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Newton\PYZhy{}CG}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{jac}\PY{o}{=}\PY{n}{delta\PYZus{}f}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Print the result}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The minimum of f using scipy.optimize.minimize is in }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
      \PY{n}{result}\PY{o}{.}\PY{n}{x}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ and the minimum value is : }\PY{l+s+s2}{\PYZdq{}}
      \PY{p}{,}\PY{n}{result}\PY{o}{.}\PY{n}{fun}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
The minimum of f using the manually written algorithm is in  [ 4.          3.
-5.00095904]  and the minimum value is :  3.383828899365421e-12
The minimum of f using scipy.optimize.minimize is in  [ 4.          3.00000003
-4.99737168]  and the minimum value is :  1.908869103936226e-10
    \end{Verbatim}

    \newpage

\subsection{Linear programming}\label{linear-programming}

    This type of optimization tries to find an extreme of a linear function
\(F(\pmb{x})\), \textbf{called the objective function}, given a set of
constraints that are linear equations or inequalities. Based on the type
of constraints and the extreme of the function, a linear program can be
written in different forms.

The following proposition is called a linear program in \textbf{standard
form}:

Minimize:

\[
F(x_1, \ldots, x_n) = c_1 x_1 + c_2 x_2 + \ldots + c_n x_n
\]

Subject to:

\[
\begin{aligned}
a_{1,1}x_1 + \ldots + a_{1,n}x_n &= b_1 \\
\vdots \\
a_{k,1}x_1 + \ldots + a_{k,n}x_n &= b_k \\
\end{aligned}
\]

\[
x_1, \ldots, x_n \geq 0
\]

Or represented with matrices:

Minimize:

\[
F(\pmb{x}) = c^T \pmb{x}
\]

Subject to:

\[
A\pmb{x} = B \quad \text{where} \quad \pmb{x} \geq 0
\]

A linear program can be given in a \textbf{nonstandard form}, and the
difference between a standard and nonstandard program is in the set of
constraints. If the set of constraints defined by the matrices
\(A \cdot \pmb{x}\) and \(B\) contains inequalities, then the linear
program is in a nonstandard form.

The solution of the linear program is the vector
\(\pmb{x}(x_1, \ldots, x_n)\) that maximizes/minimizes the function
\(F\).

\emph{Some authors define the standard form in a way that the goal of
the problem is to maximize the objective function.}

Every solution \(\pmb{x}\) for \(F(\pmb{x})\) that satisfies the set of
constraints is called a feasible point.

A solution to a standard the linear program is \(\pmb{x}\) that
minimizes \(F\) for the given constraints. There can be more than one
solution for the linear program.

Every linear program in a nonstandard form can be converted into a
standard form. This is done by introducing additional variables for
every inequality. In case that the goal of the linear problem is to
maximize the objective function \(F(\pmb{x})\) than the function
\(F(\pmb{x})\) can be replaced with a function \(G(\pmb{x})\) just by
multiplying \(F(\pmb{x})\) with -1, \(G(\pmb{x})=-F(\pmb{x})\) as the is
maximum for \(F\) is achieved in the same value for \(\pmb{x}\) as the
maximum for \(G\).

For example: \(a_1 x_1 \leq 10\) is transformed to a linear equation as
\(a_1 x_1 + s_1 = 10\), for \(s \geq 0\).

Example, the following program is given in a nonstandard form:

\[
\begin{aligned}
\text{minimize: } F(x_1, x_2) &= 4x_1 + 5x_2 \\
\text{subject to:} \\
1x_1 + 1x_2 &\leq 8 \\
1x_1 + 3x_2 &\leq 18 \\
2x_1 + 1x_2 &\leq 14 \\
x_1, x_2 &\geq 0
\end{aligned}
\]

The standard form of the program is:

\[
\begin{aligned}
\text{minimize: } F(x_1, x_2) &= 4x_1 + 5x_2 \\
\text{subject to:} \\
1x_1 + 1x_2 + s_1 &= 8 \\
1x_1 + 3x_2 + s_2 &= 18 \\
2x_1 + 1x_2 + s_3 &= 14 \\
x_1, x_2, s_1, s_2, s_3 &\geq 0
\end{aligned}
\]

or:

\[
\begin{aligned}
\text{minimize: } F(x_1, x_2) &= 4x_1 + 5x_2 \\
\text{subject to: } \\
1x_1 + 1x_2 + 1s_1 + 0s_2 + 0s_3 &= 8 \\
1x_1 + 3x_2 + 0s_1 + 1s_2 + 0s_3 &= 18 \\
2x_1 + 1x_2 + 0s_1 + 0s_2 + 1s_3 &= 14 \\
x_1, x_2, s_1, s_2, s_3 &\geq 0
\end{aligned}
\]

In the general case, a nonstandard linear program:

\[
\begin{aligned}
F(\pmb{x}) &= c^T \pmb{x} \\
A \pmb{x} &\leq B \\
\text{where} \quad \pmb{x} &\geq 0
\end{aligned}
\]

can be transformed to a standard one like this:

\[
\begin{aligned}
F(\pmb{x}) &= c^T \pmb{x} \\
[A, I] \begin{bmatrix} \pmb{x} \\ S \end{bmatrix} &= B \\
\text{where:} \\
\pmb{x} &\geq 0, \\
S &\geq 0
\end{aligned}
\] - all values of \(\pmb{x}\) and \(S\) are greater than or equal to
\(0\) and \(I\) is an identity matrix.

\subsubsection{Simplex algorithm}\label{simplex-algorithm}

The simplex method is a method that solves a liner program in standard
form.

\textbf{Example}. Develop a linear program algorithm and solve the
following program:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{  Minimize:}
\NormalTok{          F(x\_1,x\_2) = 7*x\_1 + 6*x\_2}
\NormalTok{  Subject to:}
\NormalTok{         2*x\_1 + x\_2 \textless{}= 3}
\NormalTok{         x\_1 + 4*x\_2 \textless{}= 4}
\NormalTok{            x\_1, x\_2 \textgreater{}= 0}
\end{Highlighting}
\end{Shaded}

\emph{({[}8{]}, Example 16.3 (An introduction to optimization) Page
306)}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{132}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Example 16.3 \PYZdq{}An introduction to optimization\PYZdq{} Page 306:}
\PY{c+c1}{\PYZsh{}}
\PY{c+c1}{\PYZsh{}               Maximize:}
\PY{c+c1}{\PYZsh{}                        G(x\PYZus{}1,x\PYZus{}2) = 7*x\PYZus{}1 + 6*x\PYZus{}2}
\PY{c+c1}{\PYZsh{}               Subject to:}
\PY{c+c1}{\PYZsh{}                      2*x\PYZus{}1 + x\PYZus{}2 \PYZlt{}= 3}
\PY{c+c1}{\PYZsh{}                      x\PYZus{}1 + 4*x\PYZus{}2 \PYZlt{}= 4}
\PY{c+c1}{\PYZsh{}                         x\PYZus{}1, x\PYZus{}2 \PYZgt{}= 0}
\PY{c+c1}{\PYZsh{}}
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{c+c1}{\PYZsh{} By convection of this text we transform the Maximize to a Minimize problem}
\PY{c+c1}{\PYZsh{}}
\PY{c+c1}{\PYZsh{}               Minimize:}
\PY{c+c1}{\PYZsh{}                        F(x\PYZus{}1,x\PYZus{}2) = \PYZhy{} 7*x\PYZus{}1 \PYZhy{} 6*x\PYZus{}2}
\PY{c+c1}{\PYZsh{}               Subject to:}
\PY{c+c1}{\PYZsh{}                      2*x\PYZus{}1 + x\PYZus{}2 \PYZlt{}= 3}
\PY{c+c1}{\PYZsh{}                      x\PYZus{}1 + 4*x\PYZus{}2 \PYZlt{}= 4}
\PY{c+c1}{\PYZsh{}                         x\PYZus{}1, x\PYZus{}2 \PYZgt{}= 0}
\PY{c+c1}{\PYZsh{}}

\PY{c+c1}{\PYZsh{} First step (1) is to prepare the linear program}
\PY{c+c1}{\PYZsh{}\PYZsh{} 1.1 Transform the linear program in to it\PYZsq{}s standard form}
\PY{c+c1}{\PYZsh{} 2*x\PYZus{}1 + 1*x\PYZus{}2 + 1*s\PYZus{}1 + 0*s\PYZus{}2 = 3}
\PY{c+c1}{\PYZsh{} 1*x\PYZus{}1 + 4*x\PYZus{}2 + 0*s\PYZus{}1 + 1*s\PYZus{}2 = 4}

\PY{c+c1}{\PYZsh{} C contains the params of the objective function}
\PY{n}{C} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{7}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{6}\PY{p}{]}\PY{p}{)}
\PY{n}{A} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\PY{n}{B} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\PY{n}{I} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Creates a simplex table from the linear expressions parameters A, I, B and F}
\PY{k}{def} \PY{n+nf}{create\PYZus{}simplex\PYZus{}table}\PY{p}{(}\PY{n}{A}\PY{p}{,}\PY{n}{B}\PY{p}{,}\PY{n}{C}\PY{p}{,}\PY{n}{I}\PY{p}{)}\PY{p}{:}
    \PY{n}{A\PYZus{}C} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{vstack}\PY{p}{(}\PY{p}{(}\PY{n}{A}\PY{p}{,}\PY{n}{C}\PY{p}{)}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{n}{A\PYZus{}C}\PY{p}{)}
    \PY{n}{A\PYZus{}C\PYZus{}I} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{hstack}\PY{p}{(}\PY{p}{(}\PY{n}{A\PYZus{}C}\PY{p}{,}\PY{n}{I}\PY{p}{)}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{n}{A\PYZus{}C\PYZus{}I}\PY{p}{)}
    \PY{n}{A\PYZus{}C\PYZus{}I\PYZus{}B} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{hstack}\PY{p}{(}\PY{p}{(}\PY{n}{A\PYZus{}C\PYZus{}I}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{vstack}\PY{p}{(}\PY{p}{(}\PY{n}{B}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}\PY{p}{)}\PY{p}{)}\PY{p}{)}
    \PY{k}{return} \PY{n}{A\PYZus{}C\PYZus{}I\PYZus{}B}


\PY{c+c1}{\PYZsh{} This helper function returns the row and colum of the smallest value in the last row of a matrix}
\PY{k}{def} \PY{n+nf}{find\PYZus{}smallest\PYZus{}value\PYZus{}in\PYZus{}the\PYZus{}last\PYZus{}row}\PY{p}{(}\PY{n}{table\PYZus{}in}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Get the last row of the table\PYZus{}in}
    \PY{n}{last\PYZus{}row} \PY{o}{=} \PY{n}{table\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}
    \PY{c+c1}{\PYZsh{} Find the index of the smallest value in the last row}
    \PY{n}{min\PYZus{}value\PYZus{}index} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{argmin}\PY{p}{(}\PY{n}{last\PYZus{}row}\PY{p}{[}\PY{p}{:}\PY{n+nb}{len}\PY{p}{(}\PY{n}{last\PYZus{}row}\PY{p}{)}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} Return the smallest value, its row index, and column index}
    \PY{k}{return} \PY{n}{min\PYZus{}value\PYZus{}index}\PY{p}{,} \PY{n}{last\PYZus{}row}\PY{p}{[}\PY{n}{min\PYZus{}value\PYZus{}index}\PY{p}{]}

\PY{c+c1}{\PYZsh{} Return the smallest ratio, matrix[i,lastColumn]/matrix[i,column]}
\PY{k}{def} \PY{n+nf}{find\PYZus{}smallest\PYZus{}ratio}\PY{p}{(}\PY{n}{table\PYZus{}in}\PY{p}{,} \PY{n}{column\PYZus{}in}\PY{p}{)}\PY{p}{:}
    \PY{n}{ratios} \PY{o}{=} \PY{p}{[}\PY{p}{]}  \PY{c+c1}{\PYZsh{} Store the ratios}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{table\PYZus{}in}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{:}  \PY{c+c1}{\PYZsh{} Exclude the last row}
        \PY{k}{if} \PY{n}{table\PYZus{}in}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{[}\PY{n}{column\PYZus{}in}\PY{p}{]} \PY{o}{!=} \PY{l+m+mi}{0}\PY{p}{:}  \PY{c+c1}{\PYZsh{} Avoid division by zero}
            \PY{n}{ratio} \PY{o}{=} \PY{n}{table\PYZus{}in}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{/} \PY{n}{table\PYZus{}in}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{[}\PY{n}{column\PYZus{}in}\PY{p}{]}
            \PY{n}{ratios}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{p}{(}\PY{n}{i}\PY{p}{,} \PY{n}{ratio}\PY{p}{)}\PY{p}{)}  \PY{c+c1}{\PYZsh{} Store (index, ratio) tuple}
        \PY{k}{else}\PY{p}{:}
            \PY{n}{ratios}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{p}{(}\PY{n}{i}\PY{p}{,} \PY{k+kc}{None}\PY{p}{)}\PY{p}{)}  \PY{c+c1}{\PYZsh{} Set value to None if division by zero}
    \PY{n}{min\PYZus{}index}\PY{p}{,} \PY{n}{min\PYZus{}value} \PY{o}{=} \PY{n+nb}{min}\PY{p}{(}\PY{p}{(}\PY{n}{pair} \PY{k}{for} \PY{n}{pair} \PY{o+ow}{in} \PY{n}{ratios} \PY{k}{if} \PY{n}{pair}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{)}\PY{p}{,} \PY{n}{key}\PY{o}{=}\PY{k}{lambda} \PY{n}{x}\PY{p}{:} \PY{n}{x}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{default}\PY{o}{=}\PY{p}{(}\PY{k+kc}{None}\PY{p}{,} \PY{k+kc}{None}\PY{p}{)}\PY{p}{)}
    \PY{k}{return} \PY{n}{min\PYZus{}index}\PY{p}{,} \PY{n}{min\PYZus{}value}

\PY{k+kn}{from} \PY{n+nn}{sympy} \PY{k+kn}{import} \PY{n}{Matrix}

\PY{k}{def} \PY{n+nf}{custom\PYZus{}pivot\PYZus{}column}\PY{p}{(}\PY{n}{table\PYZus{}in}\PY{p}{,} \PY{n}{pivot\PYZus{}row}\PY{p}{,} \PY{n}{pivot\PYZus{}col}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Convert the matrix to a NumPy array for easier manipulation}
    \PY{n}{np\PYZus{}matrix} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{n}{table\PYZus{}in}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} Divide the pivot row by the pivot element to make it 1}
    \PY{n}{pivot\PYZus{}element} \PY{o}{=} \PY{n}{np\PYZus{}matrix}\PY{p}{[}\PY{n}{pivot\PYZus{}row}\PY{p}{,} \PY{n}{pivot\PYZus{}col}\PY{p}{]}
    \PY{n}{np\PYZus{}matrix}\PY{p}{[}\PY{n}{pivot\PYZus{}row}\PY{p}{,} \PY{p}{:}\PY{p}{]} \PY{o}{/}\PY{o}{=} \PY{n}{pivot\PYZus{}element}
    \PY{c+c1}{\PYZsh{} Eliminate other elements in the same column}
    \PY{n}{num\PYZus{}rows} \PY{o}{=} \PY{n}{np\PYZus{}matrix}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{num\PYZus{}rows}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n}{i} \PY{o}{!=} \PY{n}{pivot\PYZus{}row}\PY{p}{:}
            \PY{n}{ratio} \PY{o}{=} \PY{n}{np\PYZus{}matrix}\PY{p}{[}\PY{n}{i}\PY{p}{,} \PY{n}{pivot\PYZus{}col}\PY{p}{]}
            \PY{c+c1}{\PYZsh{} //todo add it in python tutorial for matrixes, manipulations with row and column}
            \PY{n}{np\PYZus{}matrix}\PY{p}{[}\PY{n}{i}\PY{p}{,} \PY{p}{:}\PY{p}{]} \PY{o}{\PYZhy{}}\PY{o}{=} \PY{n}{ratio} \PY{o}{*} \PY{n}{np\PYZus{}matrix}\PY{p}{[}\PY{n}{pivot\PYZus{}row}\PY{p}{,} \PY{p}{:}\PY{p}{]}
    \PY{c+c1}{\PYZsh{} Convert the modified NumPy array back to a SymPy Matrix}
    \PY{n}{pivoted\PYZus{}table} \PY{o}{=} \PY{n}{Matrix}\PY{p}{(}\PY{n}{np\PYZus{}matrix}\PY{p}{)}
    \PY{k}{return} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{n}{pivoted\PYZus{}table}\PY{p}{)}

\PY{k}{def} \PY{n+nf}{simplex\PYZus{}method\PYZus{}step\PYZus{}function}\PY{p}{(}\PY{n}{simplex\PYZus{}matrix\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{c+c1}{\PYZsh{} Step 1 simplex algorithm, find the column, i of the value that has biggest negative value,}
  \PY{c+c1}{\PYZsh{} This is the steppes direction of increase for the F function}
  \PY{n}{column}\PY{p}{,} \PY{n}{value} \PY{o}{=} \PY{n}{find\PYZus{}smallest\PYZus{}value\PYZus{}in\PYZus{}the\PYZus{}last\PYZus{}row}\PY{p}{(}\PY{n}{simplex\PYZus{}matrix\PYZus{}in}\PY{p}{)}
  \PY{c+c1}{\PYZsh{} Find the row of the constraint that gives the smallest constraint for xi.}
  \PY{n}{row}\PY{p}{,} \PY{n}{value} \PY{o}{=} \PY{n}{find\PYZus{}smallest\PYZus{}ratio}\PY{p}{(}\PY{n}{simplex\PYZus{}matrix\PYZus{}in}\PY{p}{,} \PY{n}{column}\PY{p}{)}
  \PY{k}{return} \PY{n}{custom\PYZus{}pivot\PYZus{}column}\PY{p}{(}\PY{n}{Matrix}\PY{p}{(}\PY{n}{simplex\PYZus{}matrix\PYZus{}in}\PY{p}{)}\PY{p}{,}\PY{n}{row}\PY{p}{,}\PY{n}{column}\PY{p}{)}


\PY{c+c1}{\PYZsh{} The algorithm requires the data form the equations to be in a form of A\PYZus{}C\PYZus{}I\PYZus{}B matrix, lets rename this matrix to simplex\PYZus{}matrix, for context}
\PY{c+c1}{\PYZsh{} simplex\PYZus{}table = A\PYZus{}C\PYZus{}I\PYZus{}B}
\PY{n}{simplex\PYZus{}table} \PY{o}{=} \PY{n}{create\PYZus{}simplex\PYZus{}table}\PY{p}{(}\PY{n}{A}\PY{p}{,}\PY{n}{B}\PY{p}{,}\PY{n}{C}\PY{p}{,}\PY{n}{I}\PY{p}{)}

\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Simplex Table\PYZhy{}\PYZhy{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{simplex\PYZus{}table}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZhy{}\PYZhy{}Simplex Table}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{n}{x\PYZus{}approximations} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{n}{x\PYZus{}approximations}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{simplex\PYZus{}table}\PY{p}{)}

\PY{k}{def} \PY{n+nf}{stop\PYZus{}conditions\PYZus{}simplex\PYZus{}method}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{n}{column}\PY{p}{,} \PY{n}{min\PYZus{}column\PYZus{}value}  \PY{o}{=} \PY{n}{find\PYZus{}smallest\PYZus{}value\PYZus{}in\PYZus{}the\PYZus{}last\PYZus{}row}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
  \PY{n}{row}\PY{p}{,} \PY{n}{min\PYZus{}row\PYZus{}value}  \PY{o}{=} \PY{n}{find\PYZus{}smallest\PYZus{}ratio}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{column}\PY{p}{)}
  \PY{k}{return} \PY{n}{min\PYZus{}column\PYZus{}value} \PY{o}{\PYZlt{}} \PY{l+m+mi}{0} \PY{o+ow}{and} \PY{n}{min\PYZus{}row\PYZus{}value} \PY{o}{!=} \PY{k+kc}{None} \PY{o+ow}{and} \PY{n}{min\PYZus{}row\PYZus{}value} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}


\PY{k}{def} \PY{n+nf}{basic\PYZus{}simplex\PYZus{}method}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{,} \PY{n}{stop\PYZus{}conditions\PYZus{}function\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{k}{while}\PY{p}{(}\PY{n}{stop\PYZus{}conditions\PYZus{}function\PYZus{}in}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{)}\PY{p}{)}\PY{p}{:}
    \PY{n}{simplex\PYZus{}step\PYZus{}table} \PY{o}{=} \PY{n}{simplex\PYZus{}method\PYZus{}step\PYZus{}function}\PY{p}{(}\PY{n}{approximations\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
    \PY{n}{approximations\PYZus{}in}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{simplex\PYZus{}step\PYZus{}table}\PY{p}{)}


\PY{n}{basic\PYZus{}simplex\PYZus{}method}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{,} \PY{n}{stop\PYZus{}conditions\PYZus{}simplex\PYZus{}method}\PY{p}{)}

\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Minimum is achieved in the vector}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{[}\PY{p}{:}\PY{n+nb}{len}\PY{p}{(}\PY{n}{C}\PY{p}{)}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The minimum is}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
[[ 2  1]
 [ 1  4]
 [-7 -6]]
[[ 2  1  1  0  0]
 [ 1  4  0  1  0]
 [-7 -6  0  0  1]]
Simplex Table--
[[ 2  1  1  0  0  3]
 [ 1  4  0  1  0  4]
 [-7 -6  0  0  1  0]]
--Simplex Table
Minimum is achieved in the vector
[8/7 5/7]
The minimum is
86/7
    \end{Verbatim}

    \newpage

\subsection{Two phase simplex}\label{two-phase-simplex}

The two phase simplex algorithm is a generalization of the simplex
algorithm, it is required since the the basic feasible solution is not
always obvious, this method standardizes the simplex algorithm. Example
when to use the Two phase simplex: * Usually the basic feasible solution
is for every \(x_0,x_1,...x_n = \pmb{x} , x_i = 0\). If this \(\pmb{x}\)
does not solve the function than it can be said that the basic feasible
solution is not obvious. In this case the the two phase simplex method
can be used.

The algorithm contains two phases. * Phase 1 Is used to find a
\emph{basic feasible solution} * Phase 2 Using the \emph{basic feasible
solution} find the optimal solution

\textbf{Canonical form of the simplex table:} Before applying the
simplex method or the phase two of the ``Two phase simplex method'' the
table needs to be in canonical form, this form needs to have 0 values
for the columns of the base vectors in the last row, the row that holds
the parameters of objective function. This is easily done with linear
transformations.

\textbf{Example}. Develop an algorithm for the two phase simplex method
and solve the linear program: Minimize : 2x\_1 + 3x\_2 Subject to :
4x\_1 + 2x\_2 \textgreater= 12 x\_1 + 4x\_2 \textgreater= 6 x1,x2
\textgreater= 0 \emph{({[}8{]}, Example 16.4, ``Introduction to
Optimization'', page 308)}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{}  Example 16.4,  *[8]*,  Introduction to Optimization, page 308}
\PY{c+c1}{\PYZsh{}          minimize :}
\PY{c+c1}{\PYZsh{}                     2x\PYZus{}1 + 3x\PYZus{}2}
\PY{c+c1}{\PYZsh{}        subject to :}
\PY{c+c1}{\PYZsh{}                     4x\PYZus{}1 + 2x\PYZus{}2 \PYZgt{}= 12}
\PY{c+c1}{\PYZsh{}                      x\PYZus{}1 + 4x\PYZus{}2 \PYZgt{}= 6}
\PY{c+c1}{\PYZsh{}                           x1,x2 \PYZgt{}= 0}


\PY{c+c1}{\PYZsh{} Initially, the problem is transformed in the standard form}
\PY{c+c1}{\PYZsh{}          minimize :}
\PY{c+c1}{\PYZsh{}                     2x\PYZus{}1 + 3x\PYZus{}2}
\PY{c+c1}{\PYZsh{}        subject to :}
\PY{c+c1}{\PYZsh{}                     4x\PYZus{}1 + 2x\PYZus{}2 \PYZhy{} x\PYZus{}3 \PYZhy{} 0*x\PYZus{}4 = 12}
\PY{c+c1}{\PYZsh{}                      x\PYZus{}1 + 4x\PYZus{}2 \PYZhy{} 0*x\PYZus{}3 \PYZhy{} x\PYZus{}4 = 6}
\PY{c+c1}{\PYZsh{}                           x1, x2, x\PYZus{}3, x\PYZus{}4 \PYZgt{}= 0}
\PY{c+c1}{\PYZsh{} Since x\PYZus{}1, x\PYZus{}2 = 0 is not a solution, it can be concluded that the initial}
\PY{c+c1}{\PYZsh{} basic solution is not obvious}

\PY{c+c1}{\PYZsh{} Then artificial variables, x\PYZus{}5 and x\PYZus{}6 \PYZgt{}= 0 and a new}
\PY{c+c1}{\PYZsh{} artificial objective function x\PYZus{}5 + x\PYZus{}6, that}
\PY{c+c1}{\PYZsh{} needs to be maximized are introduced}

\PY{c+c1}{\PYZsh{} The artificial problem will have the following form:}
\PY{c+c1}{\PYZsh{}          minimize:}
\PY{c+c1}{\PYZsh{}                       x\PYZus{}5+x\PYZus{}6}
\PY{c+c1}{\PYZsh{}          subject to:}
\PY{c+c1}{\PYZsh{}                       4x\PYZus{}1 + 2x\PYZus{}2 \PYZhy{} x\PYZus{}3 \PYZhy{} 0*x\PYZus{}4 +1x\PYZus{}5 + 0x\PYZus{}6  = 12}
\PY{c+c1}{\PYZsh{}                        x\PYZus{}1 + 4x\PYZus{}2 \PYZhy{} 0*x\PYZus{}3 \PYZhy{} x\PYZus{}4 + 0x\PYZus{}5 +1x\PYZus{}6  = 6}
\PY{c+c1}{\PYZsh{}                                        x1,x2,x\PYZus{}3,x\PYZus{}4,x\PYZus{}5,x\PYZus{}6 \PYZgt{}= 0}

\PY{c+c1}{\PYZsh{} Phase one solution, optimizing the artificial objective function}

\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{k+kn}{from} \PY{n+nn}{sympy} \PY{k+kn}{import} \PY{n}{Matrix}

\PY{n}{C} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
\PY{n}{C\PYZus{}a} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(} \PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]} \PY{p}{)}
\PY{n}{A} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
              \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\PY{n}{B} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{12}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{6}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\PY{n}{I\PYZus{}a} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}\PY{p}{)}

\PY{k}{def} \PY{n+nf}{create\PYZus{}simplex\PYZus{}table}\PY{p}{(}\PY{n}{A}\PY{p}{,}\PY{n}{B}\PY{p}{,}\PY{n}{C}\PY{p}{,}\PY{n}{I}\PY{p}{)}\PY{p}{:}
    \PY{n}{A\PYZus{}I} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{hstack}\PY{p}{(}\PY{p}{(}\PY{n}{A}\PY{p}{,}\PY{n}{I\PYZus{}a}\PY{p}{)}\PY{p}{)}
    \PY{n}{A\PYZus{}I\PYZus{}C} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{vstack}\PY{p}{(}\PY{p}{(}\PY{n}{A\PYZus{}I}\PY{p}{,}\PY{n}{C}\PY{p}{)}\PY{p}{)}
    \PY{n}{A\PYZus{}I\PYZus{}C\PYZus{}B} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{hstack}\PY{p}{(}\PY{p}{(}\PY{n}{A\PYZus{}I\PYZus{}C}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{vstack}\PY{p}{(}\PY{p}{(}\PY{n}{B}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}\PY{p}{)}\PY{p}{)}\PY{p}{)}
    \PY{k}{return} \PY{n}{A\PYZus{}I\PYZus{}C\PYZus{}B}

\PY{n}{simplex\PYZus{}matrix} \PY{o}{=} \PY{n}{create\PYZus{}simplex\PYZus{}table}\PY{p}{(}\PY{n}{A}\PY{p}{,}\PY{n}{B}\PY{p}{,}\PY{n}{C\PYZus{}a}\PY{p}{,}\PY{n}{I\PYZus{}a}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The starting table has this form: }\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{ }\PY{l+s+si}{\PYZob{}}\PY{n}{simplex\PYZus{}matrix}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Before starting the last row or the coefficients of the optimization function}
\PY{c+c1}{\PYZsh{} need to be adjusted so that the artificial values have 0 value}
\PY{n}{simplex\PYZus{}matrix}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{\PYZhy{}}\PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{n}{simplex\PYZus{}matrix}\PY{p}{[}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{axis}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The canonical form of the table: }\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{ }\PY{l+s+si}{\PYZob{}}\PY{n}{simplex\PYZus{}matrix}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}


\PY{n}{x\PYZus{}approximations} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{n}{x\PYZus{}approximations}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{simplex\PYZus{}matrix}\PY{p}{)}

\PY{n}{basic\PYZus{}simplex\PYZus{}method}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{,} \PY{n}{stop\PYZus{}conditions\PYZus{}simplex\PYZus{}method}\PY{p}{)}

\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The phase 1 ends with the following matrix:}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{ }\PY{l+s+si}{\PYZob{}}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ }\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The maximum is}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{[}\PY{p}{:}\PY{n+nb}{len}\PY{p}{(}\PY{n}{C}\PY{p}{)}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}


\PY{c+c1}{\PYZsh{} Phase two}
\PY{c+c1}{\PYZsh{} Remove the artificial variables}
\PY{k}{def} \PY{n+nf}{remove\PYZus{}artificial\PYZus{}variables}\PY{p}{(}\PY{n}{matrix}\PY{p}{,} \PY{n}{Ia}\PY{p}{)}\PY{p}{:}
\PY{c+c1}{\PYZsh{}  todo, matrix[:,[\PYZhy{}1]] is used instead of matrix[:,\PYZhy{}1] as matrix[:,\PYZhy{}1] will return only a row and not a matrix}
  \PY{k}{return} \PY{n}{np}\PY{o}{.}\PY{n}{hstack}\PY{p}{(}\PY{p}{(}\PY{n}{matrix}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{Ia}\PY{p}{)}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{,} \PY{n}{matrix}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}\PY{p}{)}\PY{p}{)}


\PY{k}{def} \PY{n+nf}{replace\PYZus{}artificial\PYZus{}objective\PYZus{}function}\PY{p}{(}\PY{n}{table\PYZus{}in}\PY{p}{,} \PY{n}{C\PYZus{}in}\PY{p}{)}\PY{p}{:}
  \PY{n}{matrix} \PY{o}{=} \PY{n}{table\PYZus{}in}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{p}{:}\PY{p}{]}
  \PY{n}{zero\PYZus{}values\PYZus{}row} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{full}\PY{p}{(}\PY{n}{matrix}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{n}{C\PYZus{}in}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{)}
  \PY{n+nb}{sum} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{hstack}\PY{p}{(}\PY{p}{(}\PY{n}{C\PYZus{}in}\PY{p}{,} \PY{n}{zero\PYZus{}values\PYZus{}row}\PY{p}{)}\PY{p}{)}
  \PY{n}{appended}\PY{o}{=}\PY{n}{np}\PY{o}{.}\PY{n}{vstack}\PY{p}{(}\PY{p}{(}\PY{n}{matrix}\PY{p}{,}\PY{n+nb}{sum}\PY{p}{)}\PY{p}{)}
  \PY{k}{return} \PY{n}{appended}\PY{p}{;}


\PY{k+kn}{from} \PY{n+nn}{numpy}\PY{n+nn}{.}\PY{n+nn}{typing} \PY{k+kn}{import} \PY{n}{NDArray}

\PY{k}{def} \PY{n+nf}{is\PYZus{}base\PYZus{}vector}\PY{p}{(}\PY{n}{array}\PY{p}{:}\PY{n}{NDArray}\PY{p}{)}\PY{p}{:}
    \PY{n}{non\PYZus{}zero\PYZus{}count} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{count\PYZus{}nonzero}\PY{p}{(}\PY{n}{array}\PY{p}{)}
    \PY{k}{return} \PY{n}{non\PYZus{}zero\PYZus{}count} \PY{o}{==} \PY{l+m+mi}{1}

\PY{c+c1}{\PYZsh{} Expresses the objective function with the new basis, or in other words,}
\PY{c+c1}{\PYZsh{} Transform the last row so that the zeros appear in the basis columns, base\PYZus{}vectors}
\PY{k}{def} \PY{n+nf}{convert\PYZus{}to\PYZus{}canonical\PYZus{}form}\PY{p}{(}\PY{n}{table\PYZus{}in}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{column} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{table\PYZus{}in}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{p}{:}
      \PY{k}{if} \PY{n}{is\PYZus{}base\PYZus{}vector}\PY{p}{(}\PY{n}{table\PYZus{}in}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{column}\PY{p}{]}\PY{p}{)}\PY{p}{:}
        \PY{n}{row} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{flatnonzero}\PY{p}{(}\PY{n}{table\PYZus{}in}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{column}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
        \PY{n}{table\PYZus{}in}\PY{p}{[}\PY{n}{row}\PY{p}{,} \PY{p}{:}\PY{p}{]} \PY{o}{/}\PY{o}{=} \PY{n}{table\PYZus{}in}\PY{p}{[}\PY{n}{row}\PY{p}{]}\PY{p}{[}\PY{n}{column}\PY{p}{]}
        \PY{n}{table\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{p}{:}\PY{p}{]} \PY{o}{\PYZhy{}}\PY{o}{=} \PY{n}{table\PYZus{}in}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{column}\PY{p}{]}\PY{o}{*}\PY{n}{table\PYZus{}in}\PY{p}{[}\PY{n}{row}\PY{p}{]}\PY{p}{[}\PY{p}{:}\PY{p}{]}
    \PY{k}{return} \PY{n}{table\PYZus{}in}

\PY{n}{approximation} \PY{o}{=} \PY{n}{remove\PYZus{}artificial\PYZus{}variables}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{I\PYZus{}a}\PY{p}{)}
\PY{n+nb}{print} \PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Removed artificial variables from table: }\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{ }\PY{l+s+si}{\PYZob{}}\PY{n}{approximation}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ }\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n}{approximation} \PY{o}{=} \PY{n}{replace\PYZus{}artificial\PYZus{}objective\PYZus{}function}\PY{p}{(}\PY{n}{approximation}\PY{p}{,} \PY{n}{C}\PY{p}{)}
\PY{n+nb}{print} \PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Reverting back the original objective function: }\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{ }\PY{l+s+si}{\PYZob{}}\PY{n}{approximation}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ }\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{n}{phase\PYZus{}two\PYZus{}table} \PY{o}{=} \PY{n}{convert\PYZus{}to\PYZus{}canonical\PYZus{}form}\PY{p}{(}\PY{n}{approximation}\PY{p}{)}

\PY{n+nb}{print} \PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Phase two table}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print} \PY{p}{(}\PY{n}{phase\PYZus{}two\PYZus{}table}\PY{p}{)}
\PY{n}{x\PYZus{}approximations}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{phase\PYZus{}two\PYZus{}table}\PY{p}{)}
\PY{n}{basic\PYZus{}simplex\PYZus{}method}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{,} \PY{n}{stop\PYZus{}conditions\PYZus{}simplex\PYZus{}method}\PY{p}{)}

\PY{n+nb}{print} \PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The optimal solution to the linear program is: }\PY{l+s+si}{\PYZob{}}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{[}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{+w}{ }\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{,}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print} \PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{and the optimal cost is }\PY{l+s+si}{\PYZob{}}\PY{o}{\PYZhy{}}\PY{p}{(}\PY{n}{x\PYZus{}approximations}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{+w}{ }\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
The starting table has this form:
 [[ 4  2 -1  0  1  0 12]
 [ 1  4  0 -1  0  1  6]
 [ 0  0  0  0  1  1  0]]
The canonical form of the table:
 [[  4   2  -1   0   1   0  12]
 [  1   4   0  -1   0   1   6]
 [ -5  -6   1   1   0   0 -18]]
The phase 1 ends with the following matrix:
 [[1 0 -2/7 1/7 2/7 -1/7 18/7]
 [0 1 1/14 -2/7 -1/14 2/7 6/7]
 [0 0 0 0 1 1 0]]

The maximum is
[18/7 6/7]
Removed artificial variables from table:
 [[1 0 -2/7 1/7 18/7]
 [0 1 1/14 -2/7 6/7]
 [0 0 0 0 0]]

Reverting back the original objective function:
 [[1 0 -2/7 1/7 18/7]
 [0 1 1/14 -2/7 6/7]
 [2 3 0 0 0]]

Phase two table
[[1 0 -2/7 1/7 18/7]
 [0 1 1/14 -2/7 6/7]
 [0 0 5/14 4/7 -54/7]]
The optimal solution to the linear program is: [18/7 6/7],
and the optimal cost is 54/7
    \end{Verbatim}

    \newpage

\subsection{\texorpdfstring{Solving linear program with
\texttt{scipy.optimize.linprog}}{Solving linear program with scipy.optimize.linprog}}\label{solving-linear-program-with-scipy.optimize.linprog}

Python offers a convenient way for solving linear programming programs.
The \texttt{scipy} library contains a module
\texttt{scipy.optimize.linprog} that is designed for solving this type
of problems.

Let's demonstrate how to solve the previous linear program using the
\texttt{linprog} library

\begin{verbatim}
#  Example 16.4, Introduction to Optimization, page 308 [8]
#          Minimize :
#                     2x_1 + 3x_2
#        Subject to :
#                     4x_1 + 2x_2 >= 12
#                      x_1 + 4x_2 >= 6
#                         x_1,x_2 >= 0
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Initially transform the linear program so it is a minimizer.
\item
  Create a list of all coefficients from the optimization function needs
  for example \(2x_1 + 3x_2\) becomes \texttt{c={[}-2,-3{]}}.
\item
  Create matrix \(A\), this are the parameters defined by the values
  before the \(x\) variables under the subject part of the program, but
  not including the last row. In this case, the parameters will form the
  following matrix \texttt{A\ =\ {[}{[}-4,\ -2{]},\ {[}-1,\ -4{]}{]}},
  it is important to point out that the sight before every parameter
  depends on the inequality operation or equality of the row. In case
  of:
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \textgreater= the sign of the parameters changes in the entire row
  changes
\item
  \textless= the sign of the parameters stays the same in the entire
  row.
\item
  == A new matrix A\_eq is created that contains this row, and will be
  plugged in the function separately.
\item
  in case of \textless{} or \textgreater, manual work is required, as
  these rows are not excepted by the algorithm, by adding/removing a
  small number \(e\) to the requeued row in the B-vector column.
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Constructing the vector B, this is the last column of the linear
  program. In the current linear program it is the vector B={[}12,6{]}.
  It has the same number of elements or rows as the matrix A. Also it
  follows the same rules as a concerning the inequality or equality
  operator.
\end{enumerate}

\newpage

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{134}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{k+kn}{from} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{optimize} \PY{k+kn}{import} \PY{n}{linprog}

\PY{c+c1}{\PYZsh{}  Example 16.4, Introduction to Optimization, page 308 [8]}
\PY{c+c1}{\PYZsh{}          minimize :}
\PY{c+c1}{\PYZsh{}                     2x\PYZus{}1 + 3x\PYZus{}2}
\PY{c+c1}{\PYZsh{}        subject to :}
\PY{c+c1}{\PYZsh{}                     4x\PYZus{}1 + 2x\PYZus{}2 \PYZlt{}= 12}
\PY{c+c1}{\PYZsh{}                      x\PYZus{}1 + 4x\PYZus{}2 \PYZlt{}= 6}
\PY{c+c1}{\PYZsh{}                           x1,x2 \PYZgt{}= 0}

\PY{c+c1}{\PYZsh{} Objective function coefficients to minimize}
\PY{n}{c\PYZus{}obj} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Negate for standard form (Ax \PYZlt{}= b)}
\PY{n}{A\PYZus{}ineq} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\PY{n}{b\PYZus{}ineq} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{12}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{]}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Bounds for variables x1 and x2 (non\PYZhy{}negative)}
\PY{n}{bounds} \PY{o}{=} \PY{p}{[}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{k+kc}{None}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{k+kc}{None}\PY{p}{)}\PY{p}{]}

\PY{c+c1}{\PYZsh{} Solve the linear programming problem}
\PY{c+c1}{\PYZsh{} revised simplex uses the two phase simplex method descried above, but is deprecated}
\PY{c+c1}{\PYZsh{} https://docs.scipy.org/doc/scipy\PYZhy{}1.12.0/reference/optimize.linprog\PYZhy{}revised\PYZus{}simplex.html\PYZsh{}optimize\PYZhy{}linprog\PYZhy{}revised\PYZhy{}simplex}
\PY{n}{res} \PY{o}{=} \PY{n}{linprog}\PY{p}{(}\PY{n}{c}\PY{o}{=}\PY{n}{c\PYZus{}obj}\PY{p}{,} \PY{n}{A\PYZus{}ub}\PY{o}{=}\PY{n}{A\PYZus{}ineq}\PY{p}{,} \PY{n}{b\PYZus{}ub}\PY{o}{=}\PY{n}{b\PYZus{}ineq}\PY{p}{,} \PY{n}{bounds}\PY{o}{=}\PY{n}{bounds}\PY{p}{,} \PY{n}{method}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{revised simplex}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Print the results}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Optimal value:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{res}\PY{o}{.}\PY{n}{fun}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Optimal x values:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{res}\PY{o}{.}\PY{n}{x}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Optimal value: -7.714285714285714
Optimal x values: [2.57142857 0.85714286]
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/var/folders/4s/hhswlq455zv2br9bkfsygsfr0000gn/T/ipykernel\_74508/2743213689.py:2
5: DeprecationWarning: `method='revised simplex'` is deprecated and will be
removed in SciPy 1.11.0. Please use one of the HiGHS solvers (e.g.
`method='highs'`) in new code.
  res = linprog(c=c\_obj, A\_ub=A\_ineq, b\_ub=b\_ineq, bounds=bounds,
method='revised simplex')
    \end{Verbatim}

    \section{Bibliography}\label{bibliography}

\subsection{Python Tutorial}\label{python-tutorial}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  W3Schools. ``Plot Functions.''
  \url{https://www.w3schools.com/python/matplotlib_pie_charts.asp}.
\item
  Matplotlib. ``Animations.''
  \url{https://matplotlib.org/stable/gallery/animation/index.html}.
\item
  W3Schools. ``Language References.''
  \url{https://www.w3schools.com/python/}.
\item
  Turing. ``Using \texttt{sympy} with Symbols.''
  \url{https://www.turing.com/kb/derivative-functions-in-python}.
\end{enumerate}

\subsection{Linear Algebra}\label{linear-algebra}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\item
  Wikipedia. ``Dot-product.''
  \url{https://en.wikipedia.org/wiki/Dot_product\#Definition}.
\item
  Wikipedia. ``Cross Product.''
  \url{https://en.wikipedia.org/wiki/Cross_product}.
\item
  Hefferon, Jim. \emph{LINEAR ALGEBRA, Fourth Edition.}
  \url{https://www.cs.ox.ac.uk/files/12921/book.pdf}.
\end{enumerate}

\subsection{Optimization Methods}\label{optimization-methods}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{7}
\tightlist
\item
  Chong, Edwin K. P., and Stanislaw H. ak. \emph{An Introduction to
  Optimization, Second Edition.} Wiley-Interscience, 2001.
\end{enumerate}

\subsection{Simplex Method}\label{simplex-method}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{7}
\item
  Chong, Edwin K. P., and Stanislaw H. ak. \emph{An Introduction to
  Optimization, Second Edition.} Wiley-Interscience, 2001.
\item
  Schmidt, Jack. ``Simplex Method: Lab Manual.'' University of Kentucky,
  College of Arts and Sciences, Department of Mathematics.
  \url{https://www.ms.uky.edu/~jack/2010-01-MA162/2010-02-25-MA162Lab.pdf}.
\item
  Goemans, Michel. ``Linear Programming Notes.'' Massachusetts Institute
  of Technology, Department of Mathematics.
  \url{https://math.mit.edu/~goemans/18310S15/lpnotes310.pdf}.
\item
  Magnanti, Tom, and Jim Orlin. ``Optimization Methods in Business
  Analytics: Solving Linear Programs.''
  \url{https://web.mit.edu/15.053/www/AMP-Chapter-02.pdf}.
\item
  Stojiljkovi, Mirko. ``Hands-On Linear Programming: Optimization with
  Python.'' Real Python.
  \url{https://realpython.com/linear-programming-python/}.
\item
  Martinich, Joseph S. ``Linear Programming.'' University of Kentucky.
  \url{https://www.uky.edu/~dsianita/300/online/LP.pdf}.
\item
  S, Tom. ``Simplex Method Explained.'' YouTube.
  \url{https://www.youtube.com/watch?v=E72DWgKP_1Y&t=652s}.
\end{enumerate}

    \section{Libraries}\label{libraries}

\subsection{Python}\label{python}

\begin{itemize}
\tightlist
\item
  \texttt{SymPy}, https://www.sympy.org/en/index.html
\item
  \texttt{Scipy}, optimize
  https://docs.scipy.org/doc/scipy/reference/optimize.html
\item
  \texttt{matplotlib}, https://matplotlib.org
\item
  \texttt{numpy}, https://numpy.org/
\end{itemize}

\subsection{.md}\label{md}

\begin{itemize}
\tightlist
\item
  \texttt{Latex}, https://www.latex-project.org/
\end{itemize}


    % Add a bibliography block to the postdoc
    
    
    
\end{document}
